<?php
! defined ( 'P_W' ) && exit ( 'Forbidden' );  define ( 'PW_CACHE_VERSION', '1.0.0' ); define ( 'PW_CACHE_DIR', R_P . 'lib/utility' ); define ( 'PW_CACHE_CONFIG', 'cache_config' ); ! defined ( 'PW_CACHE_MEMCACHE' ) && define ( 'PW_CACHE_MEMCACHE', 'memcache' ); ! defined ( 'PW_CACHE_FILECACHE' ) && define ( 'PW_CACHE_FILECACHE', 'filecache' ); ! defined ( 'PW_CACHE_DBCACHE' ) && define ( 'PW_CACHE_DBCACHE', 'dbcache' ); class PW_CacheService { var $_services = array (); function PW_CacheService() { $this->__construct (); }  function __construct() { if (! isset ( $this->_services [PW_CACHE_CONFIG] ) || ! $this->_services [PW_CACHE_CONFIG]) { $this->_services [PW_CACHE_CONFIG] = new Cache_ServiceFactory (); } }  function set($key, $value, $expire = 600, $cacheName = null) { if (! ($cacheService = $this->_services [PW_CACHE_CONFIG]->getService ( $cacheName ))) { return false; } return $cacheService->set ( $key, $value, $expire ); }  function get($key, $cacheName = null) { if (! ($cacheService = $this->_services [PW_CACHE_CONFIG]->getService ( $cacheName ))) { return false; } return $cacheService->get ( $key ); }  function delete($key, $cacheName = null) { if (! ($cacheService = $this->_services [PW_CACHE_CONFIG]->getService ( $cacheName ))) { return false; } return $cacheService->delete ( $key ); } function increment($key, $value = 1, $cacheName = null) { if (! ($cacheService = $this->_services [PW_CACHE_CONFIG]->getService ( $cacheName ))) { return false; } return $cacheService->increment ( $key, $value ); }  function flush($cacheName = null) { if (! ($cacheService = $this->_services [PW_CACHE_CONFIG]->getService ( $cacheName ))) { return false; } return $cacheService->flush (); } }  class Cache_ServiceFactory { var $_defaultService = null; var $_services = array (); function Cache_ServiceFactory() { $this->__construct (); } function __construct() { $this->_defaultService = $this->build ( Cache_Config_Default::defaultCache () ); } function build($cacheName) { switch ($cacheName) { case PW_CACHE_MEMCACHE : return $this->getMemcacheService (); case PW_CACHE_FILECACHE : return $this->getFilecacheService (); case PW_CACHE_DBCACHE : return $this->getDbCacheService (); default : return false; } } function getService($cacheName) { return ($cacheName) ? $this->build ( $cacheName ) : $this->_defaultService; }  function getMemcacheService() { if (! isset ( $this->_services [PW_CACHE_MEMCACHE] ) || ! $this->_services [PW_CACHE_MEMCACHE]) { $this->_services [PW_CACHE_MEMCACHE] = new PW_MemcacheService (); } return $this->_services [PW_CACHE_MEMCACHE]; }  function getFilecacheService() { if (! isset ( $this->_services [PW_CACHE_FILECACHE] ) || ! $this->_services [PW_CACHE_FILECACHE]) { $this->_services [PW_CACHE_FILECACHE] = new PW_FilecacheService (); } return $this->_services [PW_CACHE_FILECACHE]; }  function getDbCacheService() { if (! isset ( $this->_services [PW_CACHE_DBCACHE] ) || ! $this->_services [PW_CACHE_DBCACHE]) { $this->_services [PW_CACHE_DBCACHE] = new PW_DbcacheService (); } return $this->_services [PW_CACHE_DBCACHE]; } }  class Cache_Config_Default {  function defaultCache() { return PW_CACHE_MEMCACHE; }  function getUnique() { return $GLOBALS['db_memcache']['hash']; } function getCurrentTime() { return $GLOBALS ['timestamp']; } }  class Cache_Config_Memcache {  function load() { return ($GLOBALS ['db_memcache']) ? array ($GLOBALS ['db_memcache'] ) : array (array ('host' => 'localhost', 'port' => 11211 ) ); } }  class Cache_Config_Filecache {  function getDirectory() { return D_P . 'data/gathercache/'; }  function getExt() { return '.php'; }  function createFile($key) { return Cache_Config_Filecache::getDirectory () . Cache_Config_Default::getUnique () . $key . Cache_Config_Filecache::getExt (); }  function readFile($fileName, $method = 'rb') { return readover ( $fileName, $method ); }  function writeFile($fileName, $data, $method = 'rb+', $ifLock = true, $ifCheckPath = true, $ifChmod = true) { return writeover ( $fileName, $data, $method, $ifLock, $ifCheckPath, $ifChmod ); } }  class Cache_Config_Dbcache { function connect() { $tmp = $GLOBALS ['db']->getMastdb(); return $tmp->sql; }  function getTable($key = null) { return 'pw_cache_storage'; } function createTable() {  } }  class PW_MemcacheService { var $_object = null; function PW_MemcacheService() { $this->__construct (); } function __construct() { $this->_load (); }  function set($key, $value, $expire = 600) { return (! $this->_check ()) ? false : $this->_object->set ( $this->_hash ( $key ), $value, 0, $expire ); } function increment($key, $value = 1) { return (! $this->_check ()) ? false : $this->_object->increment ( $this->_hash ( $key ), $value ); }  function get($key) { return (! $this->_check ()) ? false : $this->_object->get ( $this->_hash ( $key ) ); }  function delete($key) { return (! $this->_check ()) ? false : $this->_object->delete ( $this->_hash ( $key ) ); }  function flush() { return (! $this->_check ()) ? false : $this->_object->flush (); }  function close() { return (! $this->_check ()) ? false : $this->_object->close (); }  function _hash($key) { $unique = Cache_Config_Default::getUnique (); if (! is_array ( $key )) { return $unique . $key; } $_tmpKey = array (); foreach ( $key as $k ) { $_tmpKey [] = $unique . $k; } return $_tmpKey; }  function _check() { return (is_object ( $this->_object )) ? true : false; }  function _load() { if (! class_exists ( 'memcache' ) || ! ($configs = $this->_config ())) { return false; } $this->_object = new Memcache (); if (method_exists ( $this->_object, 'addServer' )) { foreach ( $configs as $config ) { $this->_object->addServer ( $config ['host'], $config ['port'] ); } } else { $this->_object->connect ( $configs [0] ['host'], $configs [0] ['port'] ); } }  function _config() { return Cache_Config_Memcache::load (); } }  class PW_FilecacheService { var $_object = null; function PW_FilecacheService() { $this->__construct (); } function __construct() { $this->_load (); }  function set($key, $value, $expire = 600) { return ($this->_check ()) ? $this->_object->write ( $this->_hash ( $key ), $value, $expire ) : false; }  function get($key) { return ($this->_check ()) ? $this->_object->read ( $this->_hash ( $key ) ) : false; }  function delete($key) { return ($this->_check ()) ? $this->_object->delete ( $this->_hash ( $key ) ) : false; }  function flush() { return ($this->_check ()) ? $this->_object->flush () : false; } function increment($key, $value = 1) { }  function _hash($key) { if (! is_array ( $key )) { return $key; } $_tmp = array (); foreach ( $key as $k ) { $_tmp [] = $k; } return $_tmp; }  function _load() { if (! $this->_object) { $this->_object = new Cache_File_OperateService (); } }  function _check() { return (is_object ( $this->_object )) ? true : false; } }  class Cache_File_OperateService {  function read($key, $method = 'rb') { if (! is_array ( $key )) { return $this->_read ( $key, $method ); } $_tmpData = array (); foreach ( $key as $k ) { $_tmpData [$k] = $this->_read ( $k, $method ); } return $_tmpData; } function _read($key, $method = 'rb') { if (! ($fileName = Cache_Config_Filecache::createFile ( $key ))) { return array (); } $data = unserialize ( Cache_Config_Filecache::readFile ( $fileName, $method ) ); $currentTime = Cache_Config_Default::getCurrentTime (); if (! $data || $data ['expire'] < $currentTime) { $this->delete ( $key ); return array (); } return $data ['value']; }  function write($key, $value, $expire = 600) { $fileName = Cache_Config_Filecache::createFile ( $key ); $expire = Cache_Config_Default::getCurrentTime () + $expire; return Cache_Config_Filecache::writeFile ( $fileName, serialize ( array ('expire' => $expire, 'value' => $value ) ) ); }  function delete($key) { $fileName = Cache_Config_Filecache::createFile ( $key ); if (! is_file ( $fileName )) return false; P_unlink ( $fileName ); }  function flush() { $directory = Cache_Config_Filecache::getDirectory (); if (! is_dir ( $directory )) { return false; } if (! ($dh = opendir ( $directory ))) { return false; } while ( (($file = readdir ( $dh )) !== false) ) { if (in_array ( $file, array ('.', '..' ) )) continue; $this->delete ( $directory . $file ); } closedir ( $dh ); } }  class PW_DbcacheService { var $_object = null; function PW_DbcacheService() { $this->__construct (); } function __construct() { $this->_load (); }  function set($key, $value, $expire = 600) { return ($this->_check ()) ? $this->_object->insert ( $this->_hash ( $key ), $value, $expire ) : false; }  function get($key) { return ($this->_check ()) ? $this->_object->get ( $this->_hash ( $key ) ) : false; }  function delete($key) { return ($this->_check ()) ? $this->_object->delete ( $this->_hash ( $key ) ) : false; }  function flush() { return ($this->_check ()) ? $this->_object->flush () : false; } function increment($key, $value = 1) { }  function _hash($key) { $unique = Cache_Config_Default::getUnique (); if (! is_array ( $key )) { return $unique . $key; } $_tmp = array (); foreach ( $key as $k ) { $_tmp [] = $unique . $k; } return $_tmp; }  function _load() { if (! $this->_object) { $this->_object = new Cache_Db_OperateService (); } }  function _check() { return (is_object ( $this->_object )) ? true : false; } }  class Cache_Db_OperateService { var $_conn = NULL; function Cache_Db_OperateService() { $this->__construct (); } function __construct() { $this->_conn = $this->connect (); }  function insert($key, $value, $expire = 600) { $expire = Cache_Config_Default::getCurrentTime () + $expire; return $this->query ( "REPLACE INTO " . $this->getTableName ( $key ) . " (ckey,cvalue,expire) VALUES (" . $this->escape ( $key ) . "," . $this->escape ( serialize ( $value ) ) . "," . $this->escape ( $expire ) . ")" ); }  function get($key) { $key = (is_array ( $key )) ? $key : array ($key ); $currentTime = Cache_Config_Default::getCurrentTime (); $query = $this->query ( "SELECT ckey,cvalue FROM " . $this->getTableName ( $key ) . " WHERE ckey IN ( " . $this->escape ( $key ) . ") AND expire >= " . $this->escape ( $currentTime ) ); $result = $this->fetchArray ( $query ); return $result; }  function delete($key) { $key = (is_array ( $key )) ? $key : array ($key ); return $this->query ( "DELETE FROM " . $this->getTableName ( $key ) . " WHERE ckey IN( " . $this->escape ( $key ) . ")" ); }  function flush() { return $this->query ( "TRUNCATE TABLE " . $this->getTableName () ); }  function query($sql) { return mysql_query ( $sql, $this->_conn ); }  function escape($key) { if (! is_array ( $key )) { return "'" . $key . "'"; } $_tmp = ''; foreach ( $key as $k ) { $_tmp .= (($_tmp) ? ',' : '') . "'" . $k . "'"; } return $_tmp; }  function fetchArray($result, $type = MYSQL_ASSOC) { $rt = array (); while ( $row = mysql_fetch_array ( $result, $type ) ) { $rt [$row ['ckey']] = unserialize ( $row ['cvalue'] ); } return $rt; }  function getTableName($key = null) { return Cache_Config_Dbcache::getTable ( $key ); }  function connect() { return Cache_Config_Dbcache::connect (); } }! defined ( 'P_W' ) && exit ( 'Forbidden' );  define ( 'PW_UPDATE', 'update' ); define ( 'PW_SELECT', 'select' ); define ( 'PW_DELETE', 'delete' ); define ( 'PW_INSERT', 'insert' ); define ( 'PW_REPLACE', 'replace' ); class PW_Gather {  function spreadCache($cacheName) { if (! $cacheName) return false; return $this->_loadGatherCache ( $cacheName ); }  function spreadQuery($operate, $tableNames, $fields, $expand = array()) { if (! S::isArray ( $tableNames )) { return false; } foreach ( $tableNames as $tableName ) { $this->_loadGatherQuery ( $operate, $tableName, $fields, $expand ); } return true; }  function spreadInfo($gatherName, $information = null, $defaultName = 'general') { if (! $gatherName) return false; return $this->_loadGatherInfo ( $gatherName, $information ); } function _loadGatherCache($cacheName) { static $_cacheNames = null; $cacheName = strtolower ( $cacheName ); if (! isset ( $_cacheNames [$cacheName] )) { $filePath = R_P . "lib/gather/gathercache/" . $cacheName . ".cache.php"; if (! is_file ( $filePath )) return false;  $className = 'GatherCache_' . $cacheName . '_Cache'; $filePath = pwPack::classPath ( $filePath, $className );  require_once S::escapePath ( $filePath );  if (! class_exists ( $className )) { return false; } $_cacheNames [$cacheName] = &new $className (); } return $_cacheNames [$cacheName]; } function _loadGatherQuery($operate, $tableName, $fields, $expand) { static $_classes = null; $tmpTableName = $tableName = strtolower ( $tableName ); $tableName = $this->_convertTableName ( $tableName ); if (! isset ( $_classes [$tableName] )) { $filePath = R_P . "lib/gather/gatherquery/" . $tableName . ".query.php"; if (! is_file ( $filePath )) return false; require_once S::escapePath ( $filePath ); $className = 'GatherQuery_UserDefine_' . $tableName; if (! class_exists ( $className )) { return false; } $_classes [$tableName] = &new $className (); } return $this->dispatchQuery ( $_classes [$tableName], $operate, $tmpTableName, $fields, $expand ); } function dispatchQuery($userDefineClass, $operate, $tableName, $fields, $expand = array()) { if (! S::isObj ( $userDefineClass ) || ! $operate || ! S::isArray ( $fields )) { return false; } $userDefineClass->init (); switch (strtolower ( $operate )) { case 'insert' : $userDefineClass->insert ( $tableName, $fields, $expand ); break; case 'replace' : $userDefineClass->insert ( $tableName, $fields, $expand ); break; case 'select' : $userDefineClass->select ( $tableName, $fields, $expand ); break; case 'update' : $userDefineClass->update ( $tableName, $fields, $expand ); break; case 'delete' : $userDefineClass->delete ( $tableName, $fields, $expand ); break; default : break; } return true; } function _loadGatherInfo($gatherName, $information, $defaultName = 'general') { $filePath = R_P . "lib/gather/gatherinfo/" . $defaultName . ".service.php"; if (! is_file ( $filePath )) return false; require_once S::escapePath ( $filePath ); $className = 'GatherInfo_' . $defaultName . '_Service'; if (! class_exists ( $className ) || ! is_callable ( array ($className, $gatherName ) )) { return false; } $object = &new $className (); return $object->$gatherName ( $information ); } function _convertTableName($tablename) { $extendTableNames = array (); if ($GLOBALS ['db_tlist']) { foreach ( $GLOBALS ['db_tlist'] as $k => $v ) { $extendTableNames ['pw_tmsgs' . ($k ? $k : '')] = 'pw_threads'; } } if ($GLOBALS ['db_plist']) { foreach ( $GLOBALS ['db_plist'] as $k => $v ) { $extendTableNames ['pw_posts' . ($k ? $k : '')] = 'pw_posts'; } } $tableNames = array ('pw_tmsgs' => 'pw_threads', 'pw_memberinfo' => 'pw_members', 'pw_memberdata' => 'pw_members', 'pw_singleright' => 'pw_members', 'pw_membercredit' => 'pw_members', 'pw_banuser' => 'pw_members', 'pw_cmembers' => 'pw_members', 'pw_membertags_relations' => 'pw_members', 'pw_forumdata' => 'pw_forums', 'pw_announce' => 'pw_forums'); $tableNames += $extendTableNames; return (isset ( $tableNames [$tablename] )) ? $tableNames [$tablename] : $tablename; } } class GatherCache_Base_Cache { var $_cacheService = null; function GatherCache_Base_Cache() { $this->__construct (); } function __construct() { $this->_cacheService = ($this->_cacheService) ? $this->_cacheService : $this->getCacheService (); } function checkMemcache() { static $isMemcache = null; if (! isset ( $isMemcache )) { $isMemcache = class_exists ( "Memcache" ) && strtolower ( $GLOBALS ['db_datastore'] ) == 'memcache'; } return $isMemcache; } function getUnique() { return $GLOBALS ['db_memcache'] ['hash']; } function getCacheService() { return L::loadClass ( 'cacheservice', 'utility' ); } }!defined('P_W') && exit('Forbidden'); class PW_ThreadsDB extends BaseDB { var $_tableName = 'pw_threads'; var $_tableName2 = 'pw_tmsgs'; var $_tableName3 = 'pw_threads_img'; var $_primaryKey = 'tid'; function insert($fieldData){ return $this->_insert($fieldData); } function update($fieldData,$id){ return $this->_update($fieldData,$id); } function delete($id){ return $this->_delete($id); } function get($id){ return $this->_get($id); } function count(){ return $this->_count(); }  function getsBythreadIds($threadIds){ $threadIds = (is_array($threadIds)) ? $threadIds : explode(",",$threadIds); foreach($threadIds as $threadId){ $table = GetTtable($threadId); $tables[$table][] = $threadId; } $threads = array(); foreach($tables as $table=>$tids){ $t = $this->_getsBythreadIds($tids,$table); $threads = array_merge($threads,$t); } $tmp = array(); foreach($threads as $t){ $tmp[$t['tid']] = $t; } $result = array(); foreach($threadIds as $threadId){ (isset($tmp[$threadId])) ? $result[] = $tmp[$threadId] : ''; } return $result; } function _getsBythreadIds($threadIds,$tmsgsTableName){ $this->_tableName2 = ($tmsgsTableName) ? $tmsgsTableName : $this->_tableName2; $threadIds = (is_array($threadIds)) ? S::sqlImplode($threadIds) : $threadIds; $query = $this->_db->query ( "SELECT t.*,th.content FROM ".$this->_tableName." t left join ".$this->_tableName2." th on t.tid=th.tid WHERE t.ifcheck = 1 AND t.fid != 0  AND t.tid in(".$threadIds.") ORDER BY t.postdate DESC" ); return $this->_getAllResultFromQuery ( $query ); } function _getFilterids(){ global $db_filterids; $_sql_where=''; if($db_filterids){ $_sql_where=" AND t.fid not in(".$db_filterids.") "; } return $_sql_where; } function getLatestThreadsCount($forumIds, $starttime, $endtime){ $_sql_where=$this->_getFilterids(); if ($forumIds) { $forumIds = (is_array ( $forumIds )) ? $forumIds : array ($forumIds ); $_sql_where .= " AND t.fid IN(" . S::sqlImplode ( $forumIds ) . ")"; } if ($starttime) { $ifpostdate = 1; $_sql_where .= " AND t.postdate > " . S::sqlEscape ( $starttime ); } if ($endtime) { $ifpostdate = 1; $_sql_where .= " AND t.postdate < " . S::sqlEscape ( $endtime ); } if ($ifpostdate == 1) { $forceIndex = 'FORCE INDEX (idx_postdate)'; } $total=$this->countSearch("SELECT count(*) as total FROM ".$this->_tableName." t ".$forceIndex." WHERE t.ifcheck = 1 AND t.fid !=0 ".$_sql_where); return ($total<500) ? $total :500; } function getLatestThreads($forumIds, $starttime, $endtime, $offset, $limit){ $threadIds = $this->_getLatestThreads($forumIds, $starttime, $endtime, $offset,$limit); if(!$threadIds) return false; $tmp = array(); foreach($threadIds as $t){ $tmp[] = $t['tid']; } return $this->getsBythreadIds($tmp); } function _getLatestThreads($forumIds, $starttime, $endtime, $offset, $limit){ $_sql_where=$this->_getFilterids(); if ($forumIds) { $forumIds = (is_array ( $forumIds )) ? $forumIds : array ($forumIds ); $_sql_where .= " AND t.fid IN(" . S::sqlImplode ( $forumIds ) . ")"; } if ($starttime) { $_sql_where .= " AND t.postdate > " . S::sqlEscape ( $starttime ); } if ($endtime) { $_sql_where .= " AND t.postdate < " . S::sqlEscape ( $endtime ); } $query = $this->_db->query ("SELECT t.tid FROM ".$this->_tableName." t WHERE t.ifcheck = 1 AND t.ifshield != 1 ".$_sql_where." ORDER BY t.postdate DESC LIMIT " . $offset . "," . $limit ); return $this->_getAllResultFromQuery ( $query ); }  function getLatestImageThreads($limit){ $limit = intval($limit); if (!$limit) return array(); $query = $this->_db->query ("SELECT t.tid,t.subject FROM ".$this->_tableName3." ti LEFT JOIN ".$this->_tableName." t USING(tid) WHERE t.ifcheck = 1 AND t.fid != 0 AND t.locked = 0 ORDER BY t.postdate DESC LIMIT ". $limit ); return $this->_getAllResultFromQuery ( $query ,'tid'); } function deleteTucoolThreadsByTids($tids){ return pwQuery::delete($this->_tableName3, 'tid IN (:tid)', array($tids)); } function getDigestThreadsCount($uid, $forumIds, $starttime, $endtime){ $_sql_where=$this->_getFilterids(); if ($uid) { $_sql_where .= ' AND t.authorid=' . S::sqlEscape($uid); } if ($forumIds) { $forumIds = (is_array ( $forumIds )) ? $forumIds : array ($forumIds ); $_sql_where .= " AND t.fid IN(" . S::sqlImplode ( $forumIds ) . ")"; } if ($starttime) { $_sql_where .= " AND t.postdate > " . S::sqlEscape ( $starttime ); } if ($endtime) { $_sql_where .= " AND t.postdate < " . S::sqlEscape ( $endtime ); } $total=$this->countSearch("SELECT count(*) as total FROM ".$this->_tableName." t WHERE t.ifcheck = 1{$_sql_where} AND t.digest IN ('1','2')"); return ($total<500) ? $total : 500; } function getDigestThreads($uid, $digest,$forumIds, $starttime, $endtime, $offset, $limit){ $threadIds = $this->_getDigestThreads($uid,$digest,$forumIds,$starttime,$endtime,$offset,$limit); if(!$threadIds) return false; $tmp = array(); foreach($threadIds as $t){ $tmp[] = $t['tid']; } return $this->getsBythreadIds($tmp); } function _getDigestThreads($uid, $digest, $forumIds, $starttime, $endtime, $offset, $limit){ $_sql_where=$this->_getFilterids(); if ($uid) { $_sql_where .= ' AND t.authorid=' . S::sqlEscape($uid); } if ($digest) { $digest = (is_array ( $digest )) ? $digest : array ($digest ); $_sql_where .= " AND t.digest IN(" . S::sqlImplode ( $digest ) . ")"; } if ($forumIds) { $forumIds = (is_array ( $forumIds )) ? $forumIds : array ($forumIds ); $_sql_where .= " AND t.fid IN(" . S::sqlImplode ( $forumIds ) . ")"; } if ($starttime) { $_sql_where .= " AND t.postdate > " . S::sqlEscape ( $starttime ); } if ($endtime) { $_sql_where .= " AND t.postdate < " . S::sqlEscape ( $endtime ); } $query = $this->_db->query ( "SELECT t.tid FROM ".$this->_tableName." t WHERE t.ifcheck = 1{$_sql_where} ORDER BY t.postdate DESC LIMIT " . $offset . "," . $limit ); return $this->_getAllResultFromQuery ( $query ); } function getThreadsCountByPostdate($postdate) { $_sql_where=$this->_getFilterids(); $total=$this->countSearch("SELECT count(*) as total FROM ".$this->_tableName." t WHERE t.ifcheck = 1 ".$_sql_where." AND postdate>=".S::sqlEscape($postdate)); return $total; } function getThreadsByPostdate($offset,$limit,$postdate) { $threadIds = $this->_getThreadsByPostdate($offset,$limit,$postdate); if(!$threadIds) return false; $tmp = array(); foreach($threadIds as $t){ $tmp[] = $t['tid']; } return $this->getsBythreadIds($tmp); } function _getThreadsByPostdate($offset,$limit,$postdate){ $_sql_where=$this->_getFilterids(); $query = $this->_db->query ("SELECT t.tid FROM ".$this->_tableName." t WHERE t.ifcheck = 1 ".$_sql_where." AND t.postdate>=".S::sqlEscape($postdate)." ORDER BY t.postdate DESC LIMIT " . $offset . "," . $limit ); return $this->_getAllResultFromQuery ( $query ); }  function countSearch($sql){ $result = $this->_db->get_one ( $sql ); return ($result) ? $result['total'] : 0; }  function getSearch($sql){ $query = $this->_db->query ($sql); return $this->_getAllResultFromQuery ( $query ); }  function getThreadsByFroumId($forumId, $offset, $limit) { $forumId = S::int($forumId); if($forumId < 1){ return false; } $query = $this->_db->query("SELECT * FROM " . $this->_tableName . " WHERE fid=" . S::sqlEscape($forumId) . "AND ifcheck=1 AND specialsort=0 ORDER BY lastpost DESC LIMIT $offset,$limit"); return $this->_getAllResultFromQuery($query, $this->_primaryKey); }  function getThreadsByThreadIds($threadIds) { if (!S::isArray($threadIds)) { return false; } $query = $this->_db->query("SELECT * FROM " . $this->_tableName . " WHERE tid IN (" . S::sqlImplode($threadIds, false) . ") ORDER BY lastpost DESC"); return $this->_getAllResultFromQuery($query, $this->_primaryKey); }  function getTmsgByThreadId($threadId) { $threadId = S::int($threadId); if($threadId < 1){ return false; } $pw_tmsgs = GetTtable($threadId); return $this->_db->get_one("SELECT * FROM $pw_tmsgs WHERE tid=" . S::sqlEscape($threadId)); }  function getThreadByThreadId($threadId) { $threadId = S::int($threadId); if($threadId < 1){ return false; } return $this->_db->get_one("SELECT * FROM ". $this->_tableName ." WHERE tid=" . S::sqlEscape($threadId)); }  function getThreadAndTmsgByThreadId($threadId) { $threadId = S::int($threadId); if($threadId < 1){ return false; } $pw_tmsgs = GetTtable($threadId); return $this->_db->get_one("SELECT t.* ,tm.* FROM {$this->_tableName} t LEFT JOIN $pw_tmsgs tm ON t.tid=tm.tid WHERE t.tid=" . S::sqlEscape($threadId)); }  function deleteByThreadId($threadId) { $threadId = S::int($threadId); if($threadId < 1){ return false; }  pwQuery::delete($this->_tableName, 'tid=:tid', array($threadId)); return $this->_db->affected_rows(); }  function deleteByThreadIds($threadIds) { if(!S::isArray($threadIds)){ return false; }  pwQuery::delete($this->_tableName, 'tid IN (:tid)', array($threadIds)); return $this->_db->affected_rows(); }  function deleteByForumId($forumId) { $forumId = S::int($forumId); if($forumId < 1){ return false; }  pwQuery::delete($this->_tableName, 'fid=:fid', array($forumId)); return $this->_db->affected_rows(); }  function deleteByAuthorId($authorId) { $authorId = S::int($authorId); if($authorId < 1){ return false; }  pwQuery::delete($this->_tableName, 'authorid=:authorid', array($authorId)); return $this->_db->affected_rows(); } function setTpcStatusByThreadIds($tids,$mask){ $this->_db->update("UPDATE $this->_tableName SET tpcstatus=tpcstatus & ".S::int($mask)." WHERE tid IN(".S::sqlImplode($tids).")"); } } !defined('P_W') && exit('Forbidden'); define('PW_NAV_TYPE_MAIN', 'main'); define('PW_NAV_TYPE_HEAD_LEFT', 'head_left'); define('PW_NAV_TYPE_HEAD_RIGHT', 'head_right'); define('PW_NAV_TYPE_FOOT', 'foot');  class PW_NavConfig { function add($navType, $fieldsData) { if (!$this->_checkNavType($navType)) return 0; $navConfigDb = $this->_getNavConfigDB(); $fieldsData['type'] = $navType; isset($fieldsData['style']) && $fieldsData['style'] = $this->_encodeStyleField($fieldsData['style']); isset($fieldsData['pos']) && $fieldsData['pos'] = $this->_encodePosField($fieldsData['pos']); return $navConfigDb->add($fieldsData); } function get($navId) { $navConfigDb = $this->_getNavConfigDB(); $data = $navConfigDb->get($navId); if (!$data) return null; $data['style'] = $this->_decodeStyleField($data['style']); $data['pos'] = $this->_decodePosField($data['pos']); return $data; } function getByKey($navKey, $navType = '') { $navKey = trim($navKey); if ('' == $navKey) return null; $navConfigDb = $this->_getNavConfigDB(); return $navConfigDb->getByKey($navKey, $navType); } function update($navId, $fieldsData) { if ($navId <= 0) return 0; $navConfigDb = $this->_getNavConfigDB(); isset($fieldsData['style']) && $fieldsData['style'] = $this->_encodeStyleField($fieldsData['style']); isset($fieldsData['pos']) && $fieldsData['pos'] = $this->_encodePosField($fieldsData['pos']); return $navConfigDb->update($navId, $fieldsData); } function controlShowByKey($navKey, $isShow = false) { $navKey = trim($navKey); if ('' == $navKey) return 0; $navConfigDb = $this->_getNavConfigDB(); return $navConfigDb->updateByKey($navKey, array('isshow'=>$isShow ? 1 : 0)); } function delete($navId) { if ($navId <= 0) return 0; $navIds = array($navId); $navConfigDb = $this->_getNavConfigDB(); $data = $navConfigDb->get($navId); if (!$data) return 0; foreach ($navConfigDb->findSubNavsByType($data['type'], $navId) as $nav) { $navIds[] = $nav['nid']; } return $navConfigDb->deletes($navIds); } function deleteByType($navType) { if (!$this->_checkNavType($navType)) return array(); $navConfigDb = $this->_getNavConfigDB(); return $navConfigDb->deleteByType($navType); } function deleteByKey($navKey) { $navKey = trim($navKey); if ('' == $navKey) return 0; $navConfigDb = $this->_getNavConfigDB(); $exist = $navConfigDb->getByKey($navKey); if (!$exist) return 0; return $this->delete($exist['nid']); } function findNavListByType($navType) { if (!$this->_checkNavType($navType)) return array(); $navConfigDb = $this->_getNavConfigDB(); return $navConfigDb->findByType($navType); } function relateNavList($navList) { $relativeNavs = array(); foreach ($navList as $nav) { $nav['pos'] = $this->_decodePosField($nav['pos']); if ($nav['upid']) { $relativeNavs[$nav['upid']]['subs'][$nav['nid']] = $nav; } else { $relativeNavs[$nav['nid']]['data'] = $nav; } } return $relativeNavs; } function findSubNavListByType($navType, $parentNavId = 0) { if (!$this->_checkNavType($navType)) return array(); $navConfigDb = $this->_getNavConfigDB(); return $navConfigDb->findSubNavsByType($navType, $parentNavId); } function findNavConfigs(){ static $navConfigData = array(); if(!$navConfigData){  extract(pwCache::getData(D_P . 'data/bbscache/navcache.php',false));  } if(!$navConfigData){ $navConfigDb = $this->_getNavConfigDB(); $navConfigData = $navConfigDb->findNavConfigs(); } return $navConfigData; } function findValidNavListByTypeAndPostion($navType, $postion, $currentPostion = array()) { $relativeNavs = array(); $notValidParent = array(); $currentPostionsKeeper = array(); $navConfigData = $this->findNavConfigs(); foreach ((array)$navConfigData[$navType] as $nav) { if (!$nav['isshow']) continue; $nav['iscurrent'] = false; $nav['pos'] = $this->_decodePosField($nav['pos']); $nav['style'] = $this->_decodeStyleField($nav['style']); if ($nav['upid']) { $relativeNavs[$nav['upid']]['subs'][$nav['nid']] = $nav; continue; } if ($this->_isInPos($postion, $nav['pos'])) { $currentPostionsKeeper[$nav['nid']] = $this->_compareIsCurrent($currentPostion, $nav['nkey']); $relativeNavs[$nav['nid']]['data'] = $nav; } else { $notValidParent[$nav['nid']] = $nav['nid']; } } $maxCurrentStatus = !empty($currentPostionsKeeper) ? max($currentPostionsKeeper) : 0; if ($maxCurrentStatus) { $relativeNavs[array_search($maxCurrentStatus, $currentPostionsKeeper)]['data']['iscurrent'] = true; } foreach ($notValidParent as $navId) { unset($relativeNavs[$navId]); } return $relativeNavs; }  function _compareIsCurrent($currentPostion, $navKey) { if (!is_array($currentPostion) || !count($currentPostion) || '' == $navKey) return 0; if ($currentPostion['mode'] == $navKey) return 1; if (implode("_", $currentPostion) == $navKey) return 2; return 0; }  function _getNavConfigDB() { return L::loadDB('navconfig', 'site'); } function _checkNavType($navType) { return in_array($navType, array(PW_NAV_TYPE_MAIN, PW_NAV_TYPE_HEAD_LEFT, PW_NAV_TYPE_HEAD_RIGHT, PW_NAV_TYPE_FOOT)); } function _encodePosField($posValue) { if ('-1' == $posValue) return $posValue; if (is_array($posValue)) return implode(',', $posValue); return ''; } function _decodePosField($posField) { if ('-1' == $posField) return $posField; if ($posField) return explode(',', $posField); return array(); } function _isInPos($postion, $posValue) { if ('-1' == $posValue) return true; if (is_array($posValue)) return in_array($postion, $posValue); return false; } function _encodeStyleField($styleData) { return implode("|", array($styleData['color'], $styleData['b'], $styleData['i'], $styleData['u'])); } function _decodeStyleField($styleField) { $styleField = explode('|', $styleField); return array('color'=>$styleField[0], 'b'=>$styleField[1], 'i'=>$styleField[2], 'u'=>$styleField[3]); }  function userHomeNavigation($type,$model) { if (!$type || !$model) return array(); $homenavigations = $this->findValidNavListByTypeAndPostion($type, $model); if (!S::isArray($homenavigations)) return array(); $homenavigation = array(); $homenavigation['linkup'][] = array_shift($homenavigations); $homenavigation['linkup'][] = array_shift($homenavigations); $homenavigation['linkup'][] = array_shift($homenavigations); foreach ($homenavigations as $value) { $homenavigation['linkdown'][] = $value; } return $homenavigation; } } !function_exists('readover') && exit('Forbidden');  class PW_OverPrint { var $_db = null;  var $_filename = "overprint.php";  var $_cache = true; function PW_OverPrint() { global $db; $this->_db = & $db; }  function getOverPrintIcons() { $dictory = R_P . $this->getIconPath(); if (!is_dir($dictory)) { return array(); } $files = array(); $handler = opendir($dictory); while (false !== ($file = readdir($handler))) { if ($file == "." || $file == ".." || !$this->checkIcon($file)) { continue; } $files[] = $file; } return $files; } function checkIcon($file) { if (!$file) { return false; } $ext = strtolower(substr($file, strrpos($file, ".") + 1)); if (!in_array($ext, $this->getIconExt())) { return false; } return true; }  function suckThread($tid, $operate = '', $oid = '') { if (is_array($tid)) { foreach($tid as $v) { $this->_suckThread($v, $operate, $oid); } } return $this->_suckThread($tid, $operate, $oid); } function _suckThread($tid, $operate = '', $oid = '') { $tid = intval($tid); if ($tid < 1) { return false; } if (!$operate && $oid < 0) { return false; } if ($operate) { $related = $this->getOperatesMaps($operate); if (!$related) { return false; } return $this->overprintThread($tid, $related); } $oid = intval($oid); if ($oid >= 0) { return $this->overprintThread($tid, $oid); } }  function checkThreadRelated($overprint, $operate, $tid) { if ($overprint != 2) { return false; } if ($operate == '') { return false; } $related = $this->getOperatesMaps($operate); $t_overprint = $this->getOverPrintByThreadId($tid); if ($t_overprint == $related) { return false; } return $t_overprint; } function getOverPrintByThreadId($tid) { $pw_tmsgs = GetTtable($tid); return $this->_db->get_value("SELECT overprint FROM $pw_tmsgs WHERE tid=" . S::sqlEscape($tid) . " LIMIT 1"); }  function getOverPrintIcon($related) { if (empty($related)) { return ''; } $overPrints = $this->getOverPrints(); if (!$overPrints) { return ''; } foreach($overPrints as $overprint) { if ($related < 0 && $overprint['related'] == $related) { return $this->getIconPath() . "/" . $overprint['icon']; } if ($related > 0 && $overprint['id'] == $related) { return $this->getIconPath() . "/" . $overprint['icon']; } } return ''; } function overprintThread($tid, $related) { $pw_tmsgs = GetTtable($tid);  return pwQuery::update($pw_tmsgs, 'tid=:tid', array($tid), array('overprint'=>$related)); } function getMultiUnRelatedsHTML($fid, $tids) { $html = '<div style="width:270px;">'; $html .= '<div class="h" onmousedown="read.move(event);" style="cursor: move;"><a href="javascript:;" onclick="closep();" class="adel">close</a>印戳设置</div>'; $html .= '<input type="hidden" name="overprinttids" id="overprinttids" value="' . implode(',', $tids) . '" />';  $html .= '<div class="overprint_opl cc">';  $list = $this->buildunRelatedsHTML($fid, '', '', true); $list = $list ? $list : "<div class=\"tac p10\">没有可选择的印戳</div>"; $html .= $list; $html .= '</div>';  $html .= "</div>"; $html .= '</div>'; return $html; } function getMultiUnRelatedsHTMLWithoutDiv($fid, $tids) { $html = '<div class="overprint_opl cc" style="height: auto" id="odiv">'; $list= $this->buildunRelatedsHTML($fid, '', '', true, true); $list = $list ? $list : "<div class=\"tac p10\">没有可选择的印戳</div>"; $html .= $list . '</div>'; return $html; } function getunRelatedsHTML($fid, $tid) { $isOverPrint = $this->getOverPrintByThreadId($tid); $html = '<div style="width:270px;">'; $html .= '<div class="h" onmousedown="read.move(event);" style="cursor: move;"><a href="javascript:;" onclick="closep();" class="adel">close</a>印戳设置</div>';  $html .= '<div class="overprint_opl cc">';  $list = $this->buildunRelatedsHTML($fid, $tid, $isOverPrint); $list = $list ? $list : "<div class=\"tac p10\">没有可选择的印戳</div>"; $html .= $list; $html .= '</div>';  $isOverPrint && $html .= $this->buildunRelatedTxtLI($tid, $fid, 0, "移除印戳", ''); $html .= "</div>"; $html .= '</div>'; return $html; } function buildunRelatedsHTML($fid, $tid, $isOverPrint, $isMulti = false, $withoutEvent = false) { $overprints = $this->getOverPrintUnRelateds(); if (!$overprints) { return ''; } foreach($overprints as $overprint) { if ($overprint['isopen'] == 0) {  continue; } $url = $this->getIconPath() . "/" . $overprint['icon']; $html .= $isMulti ? $this->buildMultiUnRelatedLI($fid, $overprint['id'], $overprint['title'], $url,$withoutEvent) : $this->buildunRelatedLI($tid, $fid, $overprint['id'], $overprint['title'], $url, $isOverPrint); } return $html; } function buildMultiUnRelatedLI($fid, $oid, $title, $url, $withoutEvent = false) { $img = '<img src="' . $url . '" height="40" width="40" title="' . $title . '" />'; return $withoutEvent ? "<a href=\"javascript:;\" onclick=\"setOid(this,'$oid');\">$img</a>" : '<a href="javascript:;" url="mawhole.php?action=multioverprint&step=2&ajax=1&fid=' . $fid . '&oid=' . $oid . '" onclick="return showOverPrint(this,1);">' . $img . '</a>'; } function buildunRelatedLI($tid, $fid, $oid, $title, $url, $isOverPrint) { $style = ($isOverPrint == $oid) ? "current" : ""; $img = '<img src="' . $url . '" height="40" width="40" title="' . $title . '" />'; return '<a class="' . $style . '" href="javascript:;" url="mawhole.php?action=overprint&step=2&ajax=1&fid=' . $fid . '&seltid=' . $tid . '&oid=' . $oid . '" onclick="return showOverPrint(this);">' . $img . '</a>'; } function buildunRelatedTxtLI($tid, $fid, $oid, $title, $url) { return '<div class="tar p10"><a href="javascript:;" url="mawhole.php?action=overprint&step=2&ajax=1&fid=' . $fid . '&seltid=' . $tid . '&oid=' . $oid . '" class="bta" onclick="return showOverPrint(this);">' . $title . '</a></div>'; }  function setFileCache() { if (!$this->_cache) { return; } $overPrintDao = $this->_getOverPrintDao(); $overPrints = $overPrintDao->getAll(); $tmp_overPrints = "\$overPrints=" . pw_var_export($overPrints) . ";"; pwCache::setData($this->getCacheFileName(), "<?php\r\n" . $tmp_overPrints . "\r\n?>"); return $overPrints; }  function getFileCache() { if (!$this->_cache) { return array(); }  extract(pwCache::getData(S::escapePath($this->getCacheFileName()), false)); return $overPrints; } function getCacheFileName() { return D_P . "data/bbscache/" . $this->_filename; } function getIconPath() { return "images/overprint"; } function getIconExt() { return array( 'png', 'gif', 'jpeg', 'bmp', 'jpg' ); } function getRelatedSelect($select, $name = "related", $id = "related") { $related = $this->getRelatedMaps(); return $this->_buildSelect($related, $name, $id, $select); } function getStatusSelect($select, $name = "isopen", $id = "isopen") { $selects = $this->getStatus(); return $this->_buildSelect($selects, $name, $id, $select); } function getStatus() { return array( 0 => "关闭", 1 => "启用" ); }  function getRelatedMaps() { $related = array( 0 => "无关联", '-1' => "精华", '-2' => "置顶",   '-5' => "加亮", '-6' => "提前", '-7' => "压帖", '-8' => "锁定",  ); return $related; } function getOperatesMaps($operate) { $related = array( '-1' => "digest",  '-2' => "headtopic",    '-5' => "headlight",  '-6' => "pushtopic",  '-7' => "downtopic",  '-8' => "lock",  ); $related = array_flip($related); if (!in_array($operate, array_keys($related))) { return false; } return $related[$operate]; } function addOverPrint($fieldData) { (isset($fieldData['related']) && $fieldData['related'] != "-20") && $this->checkOverPrint($fieldData['related']); $overPrintDao = $this->_getOverPrintDao(); $result = $overPrintDao->add($fieldData); if ($result) { $this->setFileCache(); } return $result; }  function checkOverPrint($related) { if ($related == '-20') { return false; } $result = $this->getOverPrintByRelated($related); if (!$result) { return false; }  $overPrintDao = $this->_getOverPrintDao(); $overPrintDao->update(array( 'related' => 0 ), $result['id']); return true; } function checkRelated($operate) { $related = $this->getOperatesMaps($operate); if (!$related) { return false; } $result = $this->getOverPrintByRelated($related); if (!$result) { return false; } if ($result['isopen'] == 0) {  return false; } return true; } function getOverPrintByRelated($related) { $overPrintDao = $this->_getOverPrintDao(); return $overPrintDao->getByRelated($related); } function getOverPrintUnRelateds() { $overPrintDao = $this->_getOverPrintDao(); return $overPrintDao->getUnRelateds(); } function updateOverPrint($fieldData, $id) { isset($fieldData['related']) && $this->checkOverPrint($fieldData['related']); $overPrintDao = $this->_getOverPrintDao(); $result = $overPrintDao->update($fieldData, $id); if ($result) { $this->setFileCache(); } return $result; } function getOverPrints($usercache = true) { if($usercache){ $overPrints = $this->getFileCache(); if ($overPrints) { return $overPrints; } } $overPrints = $this->setFileCache(); return ($overPrints) ? $overPrints : array(); } function deleteOverPrint($id) { $overPrintDao = $this->_getOverPrintDao(); $result = $overPrintDao->delete($id); if ($result) { $this->setFileCache(); } return $result; } function getOverPrint($id) { $overPrintDao = $this->_getOverPrintDao(); return $overPrintDao->get($id); } function _getOverPrintDao() { $overPrintDao = L::loadDB('overprint', 'forum'); return $overPrintDao; }  function _buildSelect($arrays, $name, $id, $select = '', $isEmpty = false) { if (!is_array($arrays)) { return ''; } $html = '<select name="' . $name . '" id="' . $id . '">'; ($isEmpty == true) && $html .= '<option value=""></option>'; foreach($arrays as $k => $v) { $selected = ($select == $k && $select != null) ? 'selected="selected"' : ""; $html .= '<option value="' . $k . '" ' . $selected . '>' . $v . '</option>'; } $html .= '</select>'; return $html; } } ! defined ( 'P_W' ) && exit ( 'Forbidden' );  ! defined ( 'PW_COLUMN' ) && define ( 'PW_COLUMN', 'column' ); ! defined ( 'PW_EXPR' ) && define ( 'PW_EXPR', 'expr' ); ! defined ( 'PW_ORDERBY' ) && define ( 'PW_ORDERBY', 'orderby' ); ! defined ( 'PW_GROUPBY' ) && define ( 'PW_GROUPBY', 'groupby' ); ! defined ( 'PW_LIMIT' ) && define ( 'PW_LIMIT', 'limit' ); ! defined ( 'PW_ASC' ) && define ( 'PW_ASC', 'asc' ); ! defined ( 'PW_DESC' ) && define ( 'PW_DESC', 'desc' ); define ( 'PW_DEBUG', 0 ); class PW_QueryBuilder {  function insertClause($tableName, $col_names) { if (! $tableName || ! is_array ( $col_names )) return ''; $sql = "INSERT INTO " . S::sqlMetadata ( $tableName ) . " "; $sql .= $this->_parseSetSQL ( $col_names ); $this->_smallHook ( 'insert', $sql, array ($tableName ), $col_names ); return $sql; }  function replaceClause($tableName, $col_names) { if (! $tableName || ! is_array ( $col_names )) return ''; $sql = "REPLACE INTO " . S::sqlMetadata ( $tableName ) . " "; $sql .= $this->_parseSetSQL ( $col_names ); $this->_smallHook ( 'replace', $sql, array ($tableName ), $col_names ); return $sql; }  function selectClause($tableName, $where_statement = null, $where_conditions = null, $expand = null) { if (! $tableName) return ''; list ( $where_statement, $fields ) = $this->_parseStatement ( $where_statement, $where_conditions ); $sql = "SELECT "; $sql .= $this->_parseColumns ( isset ( $expand [PW_COLUMN] ) ? $expand [PW_COLUMN] : '', isset ( $expand [PW_EXPR] ) ? $expand [PW_EXPR] : '' ); $sql .= " FROM " . S::sqlMetadata ( $tableName ) . " "; ($where_statement) && $sql .= " WHERE " . $where_statement; (isset ( $expand [PW_GROUPBY] )) && $sql .= $this->_parseGroupBy ( $expand [PW_GROUPBY] ); (isset ( $expand [PW_ORDERBY] )) && $sql .= $this->_parseOrderBy ( $expand [PW_ORDERBY] ); (isset ( $expand [PW_LIMIT] )) && $sql .= $this->_parseLimit ( $expand [PW_LIMIT] ); $this->_smallHook ( 'select', $sql, array ($tableName ), $fields ); return $sql; }  function updateClause($tableName, $where_statement = null, $where_conditions = null, $col_names, $expand = null) { if (! $tableName || (! is_array ( $col_names ) && ! isset ( $expand [PW_EXPR] ))) return ''; list ( $where_statement, $fields ) = $this->_parseStatement ( $where_statement, $where_conditions ); $sql = "UPDATE " . S::sqlMetadata ( $tableName ) . " "; $sql .= $this->_parseSetSQL ( $col_names, (isset ( $expand [PW_EXPR] ) ? $expand [PW_EXPR] : '') ); ($where_statement) && $sql .= " WHERE " . $where_statement; (isset ( $expand [PW_ORDERBY] )) && $sql .= $this->_parseOrderBy ( $expand [PW_ORDERBY] ); (isset ( $expand [PW_LIMIT] )) && $sql .= $this->_parseLimit ( $expand [PW_LIMIT] ); $this->_smallHook ( 'update', $sql, array ($tableName ), $fields, $col_names ); return $sql; }  function deleteClause($tableName, $where_statement = null, $where_conditions = null, $expand = null) { if (! $tableName) return ''; list ( $where_statement, $fields ) = $this->_parseStatement ( $where_statement, $where_conditions ); $sql = "DELETE FROM " . S::sqlMetadata ( $tableName ) . " "; ($where_statement) && $sql .= " WHERE " . $where_statement; (isset ( $expand [PW_ORDERBY] )) && $sql .= $this->_parseOrderBy ( $expand [PW_ORDERBY] ); (isset ( $expand [PW_LIMIT] )) && $sql .= $this->_parseLimit ( $expand [PW_LIMIT] ); $this->_smallHook ( 'delete', $sql, array ($tableName ), $fields ); return $sql; }  function buildClause($format, $parameters, $clauses = array()) { if (! $format || ! is_array ( $parameters )) return ''; list ( $sql, $matchInfo ) = $this->_parseStatement ( $format, $parameters, true ); list ( $tables, $fields ) = $this->_parseMatchs ( $matchInfo ); $this->_smallHook ( trim ( substr ( $format, 0, 7 ) ), $sql, $tables, $fields ); return $sql; }  function _parseMatchs($matchInfo) { if (! $matchInfo) { return array (array (), array () ); } foreach ( $matchInfo as $k => $v ) { if (strpos ( $k, 'pw_table' ) !== false) { $tables [] = $v; unset ( $matchInfo [$k] ); } } return array ($tables, $matchInfo ); }  function _parseSetSQL($arrays, $expr = null) { if (! is_array ( $arrays ) && ! $expr) { return ''; } $sets = " SET "; if ($expr) { foreach ( $expr as $v ) { $sets .= " " . $v . ","; } } if ($arrays) { foreach ( $arrays as $k => $v ) { $sets .= " " . S::sqlMetadata ( $k ) . " = " . S::sqlEscape ( $v ) . ","; } } $sets = trim ( $sets, "," ); return ($sets) ? $sets : ''; }  function _parseStatement($statement, $conditions, $isCheck = false) { if (! $statement || ! is_array ( $conditions )) return array ('', array () ); preg_match_all ( '/:(\w+)/', $statement, $matchs ); if (! $matchs [0]) return array ('', array () ); $fields = array ();  $seg = randstr(4); $statement = preg_replace ('/(:\w+)/', $seg . '${1}' . $seg, $statement ); foreach ( $matchs [0] as $k => $field ) { $fields [$matchs [1] [$k]] = $conditions [$k]; $param = (is_array ( $conditions [$k] )) ? S::sqlImplode ( $conditions [$k] ) : (($isCheck && strpos ( $field, 'pw_table' ) !== false) ? $conditions [$k] : S::sqlEscape ( $conditions [$k] )); $statement = str_replace ( $seg . $field . $seg, $param, $statement ); } return array ($statement, $fields ); }  function _parseColumns($columns, $statements) { $sql = ''; if ($columns) { foreach ( $columns as $column ) { $sql .= S::sqlMetadata ( $column ) . ","; } } if ($statements) { foreach ( $statements as $statement ) { $sql .= $statement . ","; } } return ($sql) ? rtrim ( $sql, ',' ) : '*'; }  function _parseGroupBy($groupBys) { if (! $groupBys) return ''; $sql = ' GROUP BY '; foreach ( $groupBys as $field ) { $sql .= S::sqlMetadata ( $field ) . ','; } $sql = rtrim ( $sql, ',' ); return $sql; }  function _parseOrderBy($orderBy) { if (! $orderBy) return ''; $orderBy = (is_array ( $orderBy )) ? $orderBy : array ($orderBy ); $sql = " ORDER BY "; foreach ( $orderBy as $field => $sort ) { if (! in_array ( strtolower ( $sort ), array (PW_DESC, PW_ASC ) )) continue; $sql .= S::sqlMetadata ( $field ) . " " . $sort . ","; } $sql = rtrim ( $sql, ',' ); return $sql; }  function _parseLimit($limits) { $offset = S::int ( $limits [0] ); $row_count = S::int ( $limits [1] ); return ($offset >= 0 && $row_count > 0) ? " LIMIT " . $offset . "," . $row_count : ''; }  function _debug($sql) { if (PW_DEBUG) { var_dump ( $sql ); } }  function _smallHook($operate, $sql, $tableNames = array(), $fields = array(), $expand = array()) { $this->_debug ( $sql ); Perf::gatherQuery ( $operate, $tableNames, $fields, $expand ); return true; } }!defined('P_W') && exit('Forbidden'); class PW_MembersDB extends BaseDB { var $_tableName = "pw_members"; var $_memberDataTableName = "pw_memberdata"; var $_memberInfoTableName = "pw_memberinfo"; var $_singleRightTableName = 'pw_singleright'; var $_userEducation = 'pw_user_education'; var $_userCareer = 'pw_user_career'; var $_primaryKey = 'uid'; function get($id) { return $this->_get($id); } function getWithJoin($userId, $withMainTable = true, $withMemberDataTable = false, $withMemberInfoTable = false) { $userId = intval($userId); if ($userId <= 0) return null; if (!$withMainTable && !$withMemberDataTable && !$withMemberInfoTable) return null; $tables = array('a' => $this->_tableName, 'b' => $this->_memberDataTableName, 'c' => $this->_memberInfoTableName); $selects = array('a' => $withMainTable, 'b' => $withMemberDataTable, 'c' => $withMemberInfoTable); $fields = array(); $firstTable = null; $firstAlias = null; $leftJoins = array(); foreach ($tables as $alias => $tableName) { if (!$selects[$alias]) continue; $fields[$alias] = $alias . ".*"; if (null === $firstTable) { $firstTable = $tableName; $firstAlias = $alias; } else { $leftJoins[] = " LEFT JOIN " . $tableName . " AS " . $alias . " ON " . $firstAlias . ".uid=" . $alias . ".uid "; } } if ($withMemberDataTable && $withMemberInfoTable) {  unset($fields['b']); $fields['b'] = "b.*, c.credit AS creditinfo"; } return $this->_db->get_one("SELECT " . implode(',', $fields) . " FROM " . $firstTable . " AS " . $firstAlias . " " . implode(' ', $leftJoins) . " WHERE " . $firstAlias . ".uid=" . $this->_addSlashes($userId)); } function insert($fieldData) { return $this->_insert($fieldData); } function update($fieldData, $id) { return $this->_update($fieldData, $id); } function updates($fieldData, $ids) { if (!$this->_check() || !$fieldData || empty($ids)) return false;  pwQuery::update('pw_members', "uid IN(:uid)" , array($ids), $fieldData); return $this->_db->affected_rows(); } function increase($userId, $increments) { $userId = intval($userId); if ($userId <= 0 || !is_array($increments)) return 0; $incrementStatement = array(); foreach ($increments as $field => $offset) { $offset = intval($offset); if (!$offset) continue; if ($offset<0){ $incrementStatement[] = $field . "=" . $field . $offset; }else{ $incrementStatement[] = $field . "=" . $field . "+" . $offset; } } if (empty($incrementStatement)) return 0;  $this->_db->update(pwQuery::buildClause("UPDATE :pw_table SET " . implode(", ", $incrementStatement) . " WHERE uid=:uid", array($this->_tableName, $userId))); return $this->_db->affected_rows(); } function delete($id) { return $this->_delete($id); } function count() { return $this->_count(); }  function setUserStatus($userId, $bit, $status = true, $num = 1) { list($userId, $bit, $num) = array(intval($userId), intval($bit), intval($num)); if ($userId <= 0 || $bit <= 0 || $num <= 0) return false; $status = sprintf('%0' . $num . 'b', $status);  --$bit; $userstatus = array(); $userstatus[] = '&~((pow(2, ' . $num . ') - 1)<<' . $bit . ')';  for ($i = $num - 1; $i >= 0; $i--) { if (isset($status[$i]) && $status[$i]) { $userstatus[] = '|(1<<' . $bit . ')'; } else { $userstatus[] = '&~(1<<' . $bit . ')'; } ++$bit; } $userstatus = 'userstatus=userstatus' . implode('', $userstatus);  $this->_db->update(pwQuery::buildClause("UPDATE :pw_table SET $userstatus WHERE uid=:uid", array($this->_tableName, $userId))); return $this->_db->affected_rows(); } function getUsersByUserNames($userNames) { $query = $this->_db->query("SELECT * FROM " . $this->_tableName . " WHERE username IN(" . S::sqlImplode($userNames) . ")"); return $this->_getAllResultFromQuery($query); } function getUsersByUserIds($userIds) { $query = $this->_db->query("SELECT * FROM " . $this->_tableName . " WHERE uid IN(" . S::sqlImplode($userIds) . ")"); return $this->_getAllResultFromQuery($query, 'uid'); } function getUserByUserName($userName, $fields = '*') { if (!$userName) return false; return $this->_db->get_one("SELECT $fields FROM " . $this->_tableName . " WHERE username = " . $this->_addSlashes($userName)); }  function getUserByUserEmails($emails) { $query = $this->_db->query("SELECT * FROM " . $this->_tableName . " WHERE email IN (" . S::sqlImplode($emails) . ")"); return $this->_getAllResultFromQuery($query); }  function getUsersByGroupIds($groupIds) { $query = $this->_db->query("SELECT * FROM " . $this->_tableName . " WHERE groupid IN(" . S::sqlImplode($groupIds) . ")"); return $this->_getAllResultFromQuery($query); }  function getUsersByGroupId($groupId) { $query = $this->_db->query("SELECT * FROM " . $this->_tableName . " WHERE groupid = " . $this->_addSlashes($groupId)); return $this->_getAllResultFromQuery($query); } function getUserInfosByUserIds($userIds) { $userIds = (is_array($userIds)) ? S::sqlImplode($userIds) : $userIds; $query = $this->_db->query("SELECT * FROM " . $this->_tableName . " m LEFT JOIN " . $this->_memberDataTableName . " md ON m.uid=md.uid WHERE m.uid IN(" . $userIds . ")"); return $this->_getAllResultFromQuery($query, 'uid'); } function findUsersOrderByUserId($limit = 1) { $limit = intval($limit); if ($limit <= 0) return array(); $query = $this->_db->query("SELECT * FROM " . $this->_tableName . " ORDER BY uid DESC LIMIT " . $limit); return $this->_getAllResultFromQuery($query); } function findNotBannedUsersOrderByUserId($limit = 1) { global $db_uidblacklist; $limit = intval($limit); if ($limit <= 0) return array(); $db_uidblacklist && $sqlWhere .= ' AND uid NOT IN (' . $db_uidblacklist . ')'; $query = $this->_db->query("SELECT * FROM " . $this->_tableName . " WHERE groupid <> 6 ".$sqlWhere." ORDER BY uid DESC LIMIT " . $limit); return $this->_getAllResultFromQuery($query); }  function countSearch($keywords) { $result = $this->_db->get_one("SELECT COUNT(*) as total FROM " . $this->_tableName . " WHERE username like " . S::sqlEscape("%$keywords%") . " LIMIT 1"); return ($result) ? $result['total'] : 0; }  function getSearch($keywords, $offset, $limit) { $query = $this->_db->query("SELECT * FROM " . $this->_tableName . " WHERE username like " . S::sqlEscape("%$keywords%") . " LIMIT " . $offset . "," . $limit); return $this->_getAllResultFromQuery($query); } function getMemberAndData($userIds){ $query = $this->_db->query("SELECT m.uid,m.username,m.gender,m.oicq,m.aliww,m.groupid,m.memberid,m.icon AS micon ,m.hack,m.honor,m.signature,m.regdate,m.medals,m.userstatus,md.postnum,md.digests,md.rvrc,md.money,md.credit,md.currency,md.thisvisit,md.lastvisit,md.onlinetime,md.starttime FROM pw_members m LEFT JOIN pw_memberdata md ON m.uid=md.uid WHERE m.uid IN (".S::sqlImplode($userIds).") "); return $this->_getAllResultFromQuery($query); } function getLatestUsersCount() { $total = $this->_db->get_value("SELECT COUNT(*) as total FROM " . $this->_tableName . " LIMIT 1"); return ($total<500) ? $total :500; } function getLatestUsers($offset, $limit) { $query = $this->_db->query ("SELECT * FROM ".$this->_tableName." ORDER BY uid DESC " .$this->_Limit($offset, $limit)); return $this->_getAllResultFromQuery ( $query ); } function getMembersAndMemberDataAndMemberInfoByUserIds($userIds, $fieldinfo = ''){ $query = $this->_db->query ( "SELECT m.*, m.icon AS micon,
		md.uid as `md.uid`, md.lastmsg,md.postnum,md.rvrc,md.money,md.credit,md.currency,md.lastvisit,md.thisvisit,md.onlinetime,md.lastpost,md.todaypost,
		md.monthpost,md.onlineip,md.uploadtime,md.uploadnum,md.starttime,md.pwdctime,md.monoltime,md.digests,md.f_num,md.creditpop,
		md.jobnum,md.lastgrab,md.follows,md.fans,md.newfans,md.newreferto,md.newcomment,md.postcheck,md.punch,md.shafa,md.newnotice,md.newrequest,md.bubble,
		mi.customdata $fieldinfo FROM pw_members m LEFT JOIN pw_memberdata md ON m.uid=md.uid LEFT JOIN pw_memberinfo mi ON mi.uid=m.uid 
		WHERE m.uid IN (".S::sqlImplode($userIds,false).")" ); return $this->_getAllResultFromQuery ( $query, 'uid' ); }  function countUsersByApartmentAndUserIds($apartment,$userIds) { $apartment = intval($apartment); if ($apartment < 1 || !s::isArray($userIds)) return 0; return $this->_db->get_value("SELECT COUNT(*) FROM " . $this->_tableName . " m LEFT JOIN " . $this->_memberDataTableName. " md USING(uid) WHERE m.uid IN(" . S::sqlImplode($userIds) . ") AND m.apartment = " . $this->_addSlashes($apartment)); }  function getUsersByApartmentAndUserIds($apartment,$userIds,$num) { $apartment = intval($apartment); $num = intval($num); if ($apartment < 1 || $num < 1 || !s::isArray($userIds)) return array(); $query = $this->_db->query("SELECT m.uid FROM " . $this->_tableName . " m LEFT JOIN " . $this->_memberDataTableName. " md USING(uid) WHERE m.uid IN(" . S::sqlImplode($userIds) . ") AND m.apartment = " . $this->_addSlashes($apartment) . ' ' . $this->_Limit(0, $num)); return $this->_getAllResultFromQuery($query); }  function countUsersByHomeAndUserIds($home,$userIds) { $home = intval($home); if ($home < 1 || !s::isArray($userIds)) return 0; return $this->_db->get_value("SELECT COUNT(*) FROM " . $this->_tableName . " m LEFT JOIN " . $this->_memberDataTableName. " md USING(uid) WHERE m.uid IN(" . S::sqlImplode($userIds) . ") AND m.home = " . $this->_addSlashes($home)); }  function getUsersByHomeAndUserIds($home,$userIds,$num) { $home = intval($home); if ($home < 1 || !s::isArray($userIds)) return array(); $query = $this->_db->query("SELECT m.uid FROM " . $this->_tableName . " m LEFT JOIN " . $this->_memberDataTableName. " md USING(uid) WHERE m.uid IN(" . S::sqlImplode($userIds) . ") AND m.home = " . $this->_addSlashes($home) . " " . $this->_Limit(0, $num)); return $this->_getAllResultFromQuery($query); }  function countUsersByCompanyidAndUserIds($companyids,$userIds) { if (!s::isArray($companyids) || !s::isArray($userIds)) return 0; return $this->_db->get_value("SELECT COUNT(*) FROM " . $this->_tableName . " m LEFT JOIN " . $this->_memberDataTableName. " md USING(uid) LEFT JOIN " . $this->_userCareer. " mc USING(uid) WHERE m.uid IN(" . S::sqlImplode($userIds) . ") AND mc.companyid IN(" . S::sqlImplode($companyids) . ")"); }  function getUsersByCompanyidAndUserIds($companyids,$userIds,$num) { if (!s::isArray($companyids) || !s::isArray($userIds)) return array(); $query = $this->_db->query("SELECT m.uid FROM " . $this->_tableName . " m LEFT JOIN " . $this->_memberDataTableName. " md USING(uid) LEFT JOIN " . $this->_userCareer. " mc USING(uid) WHERE m.uid IN(" . S::sqlImplode($userIds) . ") AND mc.companyid IN(" . S::sqlImplode($companyids) . ") " . $this->_Limit(0, $num)); return $this->_getAllResultFromQuery($query); }  function countUsersBySchoolidsAndUserIds($schoolids,$userIds) { if (!s::isArray($schoolids) || !s::isArray($userIds)) return 0; return $this->_db->get_value("SELECT COUNT(*) FROM " . $this->_tableName . " m LEFT JOIN " . $this->_memberDataTableName. " md USING(uid) LEFT JOIN " . $this->_userEducation. " me USING(uid) WHERE m.uid IN(" . S::sqlImplode($userIds) . ") AND me.schoolid IN(" . S::sqlImplode($schoolids) . ")"); }  function getUsersBySchoolidsAndUserIds($schoolids,$userIds,$num) { if (!s::isArray($schoolids) || !s::isArray($userIds)) return array(); $query = $this->_db->query("SELECT m.uid FROM " . $this->_tableName . " m LEFT JOIN " . $this->_memberDataTableName. " md USING(uid) LEFT JOIN " . $this->_userEducation. " me USING(uid) WHERE m.uid IN(" . S::sqlImplode($userIds) . ") AND me.schoolid IN(" . S::sqlImplode($schoolids) . ") " . $this->_Limit(0, $num)); return $this->_getAllResultFromQuery($query); }  function getUserInfoByUserId($userId) { $userId = intval($userId); if ($userId < 1) return array(); return $this->_db->get_one("SELECT m.uid,m.apartment,m.home,me.schoolid,mc.companyid FROM " . $this->_tableName . " m LEFT JOIN " . $this->_userEducation. " me USING(uid) LEFT JOIN " . $this->_userCareer. " mc USING(uid) WHERE m.uid = " . $this->_addSlashes($userId)); }  } !defined('P_W') && exit('Forbidden'); class PW_MemberCreditDB extends BaseDB { var $_tableName = "pw_membercredit"; function gets($userIds) { $query = $this->_db->query("SELECT * FROM " . $this->_tableName . " WHERE uid IN(" . S::sqlImplode($userIds) . ")"); return $this->_getAllResultFromQuery($query); } } !defined('P_W') && exit('Forbidden'); class PW_Ping { var $db; var $postData; var $markable; var $markset; var $userCreditInfo; var $fid; var $tid; var $forum; function PW_Ping() { global $db; $this->db = & $db; $this->markable = null; } function init($tid, $pids) { if (!is_null($this->markable)) { return; } $this->_initPostData($tid, $pids); $this->_initMarkInfo(); } function check($checkType = '') { if (empty($this->postData)) { return 'selid_illegal'; } if (!$this->forum->isForum()) { return 'data_error'; } if (empty($this->markset)) { return 'markright_set_error'; } if (!$this->markable && !$this->forum->isBM($GLOBALS['windid'])) { return 'no_markright'; } if (($return = $this->pingCheck($checkType)) !== true) { return $return; } return true; } function doPing($cid, $addpoint, $params = array()) { global $credit,$winddb,$winduid,$windid,$timestamp,$onlineip,$gp_gptype; require_once(R_P.'require/credit.php'); $add_c = $tmp = $pingLog = array(); if (is_array($cid)) { foreach ($cid as $k => $v) { if ($v && isset($credit->cType[$v]) && is_numeric($addpoint[$k]) && $addpoint[$k] <> 0) { if (!isset($this->markset[$v])) return 'masigle_credit_right'; $tmp[$v] += intval($addpoint[$k]); } } foreach ($tmp as $k => $v) { if (!$v) continue; if ($v > $this->markset[$k]['maxper'] || $v < $this->markset[$k]['minper']) { $GLOBALS['limitCreditType'] = $k; $GLOBALS['markset'] = $this->markset; return 'masigle_creditlimit'; } $add_c[$k] = $v; } } if (empty($add_c)) return 'member_credit_error'; if (strlen($params['atc_content']) > 100) return 'showping_content_too_long'; $count = count($this->postData); foreach ($add_c as $k => $v) { $allpoint = abs($v) * $count; if ($allpoint > $this->markset[$k]['leavepoint']) { $GLOBALS['leavepoint'] = $this->markset[$k]['leavepoint']; return 'masigle_point'; } if (isset($this->userCreditInfo[$k])) { $this->userCreditInfo[$k]['pingdate'] = $timestamp; $this->userCreditInfo[$k]['pingnum'] += $allpoint; } else { $this->userCreditInfo[$k] = array( 'pingdate' => $timestamp, 'pingnum' => $allpoint, 'pingtype' => $k ); }  if ($this->markset[$k]['markdt'] && $allpoint > 0) { if ($credit->get($winduid, $k) < $allpoint) return 'credit_enough'; $credit->set($winduid, $k, -$allpoint, false); } } $newcreditdb = ''; foreach ($this->userCreditInfo as $v) { $newcreditdb .= ($newcreditdb ? '|' : '') . implode("\t",$v); }  $userService = L::loadClass('UserService', 'user');  $userService->update($winduid, array(), array(), array('credit' => $newcreditdb)); $singlepoint = array_sum($add_c); require_once(R_P.'require/showimg.php');  foreach ($this->postData as $pid => $atc) { !$atc['subject'] && $atc['subject'] = substrs(strip_tags(convert($atc['content'])),35);  $credit->addLog('credit_showping', $add_c, array( 'uid' => $atc['authorid'], 'username' => $atc['author'], 'ip' => $onlineip, 'operator' => $windid, 'tid' => $this->tid, 'subject' => $atc['subject'], 'reason' => $params['atc_content'] ));  $credit->sets($atc['authorid'], $add_c, false); if (!is_numeric($pid)) {   $this->db->update(pwQuery::buildClause("UPDATE :pw_table SET ifmark=ifmark+:ifmark WHERE tid=:tid", array('pw_threads', $singlepoint, $this->tid))); $rpid = 0; } else { $rpid = $pid; } $pwSQL = $ping = array(); $affect = ''; list($ping['pingtime'],$ping['pingdate']) = getLastDate($timestamp-1);  foreach ($add_c as $key => $value) {  $pwSQL = array( 'fid' => $this->fid, 'tid' => $this->tid, 'pid' => $rpid, 'name' => $key, 'point' => $value, 'pinger'=> $windid, 'record'=> $params['atc_content'], 'pingdate'=> $timestamp, ); $affect .= ($affect ? ',' : '') . $credit->cType[$key] . ':' . $value;   $pingLogId = pwQuery::insert('pw_pinglog', $pwSQL); $pingLog[$pid][$key] = array( 'fid' => $this->fid, 'tid' => $this->tid, 'pid' => $pid, 'name' => $credit->cType[$key], 'point' => $value>0 ? "+$value" : $value, 'pinger'=> $windid, 'pingeruid'=> $winduid, 'record'=> $params['atc_content'] ? $params['atc_content'] : '-',  'pingtime'=> $ping['pingtime'], 'pingdate'=> $ping['pingdate'], 'pingLogId'=>$pingLogId ); } $this->update_markinfo($this->tid, $rpid);  Perf::gatherInfo('changeTmsgWithThreadIds', array('tid'=>$this->tid)); $this->postData[$pid]['ifmark'] = $ifmark; if ($params['ifmsg'] && !$atc['anonymous'] && $atc['author'] != $windid) {  $title = getLangInfo('writemsg','ping_title',array('sender'=>$windid,'receiver'=>$atc['author'])); $content = getLangInfo('writemsg','ping_content',array( 'manager' => $windid, 'fid' => $atc['fid'], 'tid' => $this->tid, 'pid' => $pid, 'subject' => $atc['subject'], 'postdate' => get_date($atc['postdate']), 'forum' => strip_tags($this->forum->foruminfo['name']), 'affect' => $affect, 'admindate' => get_date($timestamp), 'reason' => stripslashes($params['atc_content']), 'sender' => $windid, 'receiver' => $atc['author'] )); $this->sendMessage($atc['author'],$title,$content); } if ($gp_gptype == 'system'){ require_once(R_P.'require/writelog.php'); $log = array( 'type' => 'credit', 'username1' => $atc['author'], 'username2' => $windid, 'field1' => $this->fid, 'field2' => '', 'field3' => '', 'descrip' => 'credit_descrip', 'timestamp' => $timestamp, 'ip' => $onlineip, 'tid' => $this->tid, 'forum' => strip_tags($this->forum->foruminfo['name']), 'subject' => $atc['subject'], 'affect' => $affect, 'reason' => $params['atc_content'] ); writelog($log); } } $credit->runsql(); defined('AJAX') && $GLOBALS['pingLog'] = $pingLog;  if ($params['ifpost'] && $params['atc_content']) { $replyReturn = $this->addPost($this->tid, $params['atc_content']); } if ($GLOBALS['db_autoban'] && $singlepoint < 0) { require_once(R_P.'require/autoban.php'); foreach ($this->postData as $pid => $atc) { autoban($atc['authorid']); } } if ($this->forum->foruminfo['allowhtm'] && $_REQUEST['page'] == 1) { $StaticPage = L::loadClass('StaticPage'); $StaticPage->update($this->tid); } if (isset($replyReturn) && $replyReturn !== true) { $replyReturn = getLangInfo('msg', $replyReturn); return '评分已完成！回复失败，可能的原因是:'.$replyReturn; } return true; } function getPingLogAll($tid,$pid){ static $creditnames; is_array($creditnames) or $creditnames = pwCreditNames(); $tid = intval($tid); $pid = intval($pid); if ($tid < 1 && $pid < 1) return false; $query = $this->db->query("SELECT tid,pid,name,SUM(point) AS total FROM pw_pinglog WHERE tid=$tid AND pid=$pid AND ifhide<>1 GROUP BY `name`"); $logs = array(); while ($rt = $this->db->fetch_array($query)) { isset($creditnames[$rt['name']]) && $rt['name'] = $creditnames[$rt['name']]; $logs[$rt['name']] += $rt['total']; } return $logs; }  function deletePing($params = array()) { global $groupid,$windid,$winduid,$credit,$onlineip,$timestamp,$gp_gptype;  require_once(R_P.'require/credit.php'); foreach ($this->postData as $pid => $atc) { $rpid = $pid == 'tpc' ? '0' : $pid;  $pingdata = $this->db->get_one('SELECT * FROM pw_pinglog WHERE tid=' . S::sqlEscape($this->tid) . ' AND pid=' . S::sqlEscape($rpid) . ' AND pinger=' . S::sqlEscape($windid) . ' ORDER BY pingdate DESC LIMIT 1');  pwQuery::delete('pw_pinglog', 'id=:id', array($pingdata['id'])); $this->update_markinfo($this->tid, $rpid);  Perf::gatherInfo('changeTmsgWithThreadIds', array('tid'=>$this->tid)); $addpoint = $pingdata['point']; if (!$cid = $credit->getCreditTypeByName($pingdata['name'])) { continue; } $cName = $credit->cType[$cid]; $addpoint = $addpoint>0 ? -$addpoint : abs($addpoint); !$atc['subject'] && $atc['subject'] = substrs(strip_tags(convert($atc['content'])),35); $credit->addLog('credit_delping', array($cid => $addpoint) ,array( 'uid' => $atc['authorid'], 'username' => $atc['author'], 'ip' => $onlineip, 'operator' => $windid, 'tid' => $this->tid, 'subject' => $atc['subject'], 'reason' => $params['atc_content'] )); $credit->set($atc['authorid'], $cid, $addpoint); if (!is_numeric($pid)) {  $this->db->update(pwQuery::buildClause("UPDATE :pw_table SET ifmark=ifmark+:ifmark WHERE tid=:tid", array('pw_threads', $addpoint, $this->tid))); } if ($params['ifmsg'] && !$atc['anonymous'] && $atc['author'] != $windid) {  $title = getLangInfo('writemsg','delping_title',array('sender'=> $windid,'receiver'=>$atc['author'])); $content = getLangInfo('writemsg','delping_content',array( 'manager' => $windid, 'fid' => $atc['fid'], 'tid' => $this->tid, 'pid' => $pid, 'subject' => $atc['subject'], 'postdate' => get_date($atc['postdate']), 'forum' => strip_tags($this->forum->foruminfo['name']), 'affect' => "{$cName}:$addpoint", 'admindate' => get_date($timestamp), 'reason' => stripslashes($params['atc_content']), 'sender' => $windid, 'receiver' => $atc['author'] )); $this->sendMessage($atc['author'], $title, $content); } if ($gp_gptype == 'system'){ require_once(R_P.'require/writelog.php'); $log = array( 'type' => 'credit', 'username1' => $atc['author'], 'username2' => $windid, 'field1' => $atc['fid'], 'field2' => '', 'field3' => '', 'descrip' => 'creditdel_descrip', 'timestamp' => $timestamp, 'ip' => $onlineip, 'tid' => $this->tid, 'forum' => strip_tags($this->forum->foruminfo['name']), 'subject' => $atc['subject'], 'affect' => "$name:$addpoint", 'reason' => $params['atc_content'] ); writelog($log); } $pingLog[$pid] = $pingdata['id']; } $credit->runsql(); defined('AJAX') && $GLOBALS['pingLog'] = $pingLog; if ($this->forum->foruminfo['allowhtm'] && $_REQUEST['page']==1) { $StaticPage = L::loadClass('StaticPage'); $StaticPage->update($this->tid); } return true; }  function _getUserInfo() { global $winduid,$tdtime; if (empty($winduid)) { return array(); } $userInfo = array(); $userService = L::loadClass('UserService', 'user');  $tmpUserInfo = $userService->get($winduid, true, false, true); if ($tmpUserInfo) { $userInfo['groups'] = array(); $userInfo['credit'] = array(); if ($tmpUserInfo['groups']) { foreach (explode(',',$tmpUserInfo['groups']) as $k => $v) { is_numeric($v) && $userInfo['groups'][] = $v; } } if ($tmpUserInfo['credit']) { foreach (explode('|',$tmpUserInfo['credit']) as $v) {  $cv = explode("\t",$v); if ($cv['0'] >= $tdtime) { $userInfo['credit'][$cv['2']]['pingdate'] = $cv['0']; $userInfo['credit'][$cv['2']]['pingnum'] = $cv['1']; $userInfo['credit'][$cv['2']]['pingtype'] = $cv['2']; } } } } return $userInfo; }  function _initMarkInfo() { global $_G, $credit; require_once(R_P.'require/credit.php'); $userInfo = $this->_getUserInfo(); $tmpMark = $markset = $groupCredits = array(); $markable = $_G['markable']; $_G['markset'] = unserialize($_G['markset']); foreach ($_G['markset'] as $key => $value) { if ($value['markctype'] && is_numeric($value['marklimit'][0]) && is_numeric($value['marklimit'][1])) { $tmpMark[$key]['minper'][] = $value['marklimit'][0]; $tmpMark[$key]['maxper'][] = $value['marklimit'][1]; $tmpMark[$key]['maxcredit'][] = $value['maxcredit']; $tmpMark[$key]['markdt'] = $value['markdt']; } } if ($userInfo['groups']) { $query = $this->db->query( "SELECT gid,rkey,rvalue FROM `pw_permission`
					WHERE uid='0' 
						AND fid='0' 
						AND gid IN(" . S::sqlImplode($userInfo['groups']) . ") 
						AND rkey IN ('markset','markable') 
						AND type='basic'" ); while ($rt = $this->db->fetch_array($query)) { $groupCredits[$rt['gid']][$rt['rkey']] = $rt['rvalue']; } } foreach ($groupCredits as $gid => $p) { if (is_array($p) && $p['markable']) {  $p['markable'] > $markable && $markable = $p['markable']; $p['markset'] = (array)unserialize($p['markset']); foreach ($p['markset'] as $k => $v) { if ($v['markctype'] && is_numeric($v['marklimit'][0]) && is_numeric($v['marklimit'][1])) { $tmpMark[$k]['minper'][] = $v['marklimit'][0]; $tmpMark[$k]['maxper'][] = $v['marklimit'][1]; is_numeric($v['maxcredit']) && $tmpMark[$k]['maxcredit'][] = $v['maxcredit']; !$v['markdt'] && $tmpMark[$k]['markdt'] = 0; } } } } foreach ($tmpMark as $key => $value) { if (!isset($credit->cType[$key])) continue; $markset[$key]['minper'] = min($value['minper']); $markset[$key]['maxper'] = max($value['maxper']); $markset[$key]['maxcredit'] = max($value['maxcredit']); $markset[$key]['markdt'] = $value['markdt']; if (isset($userInfo['credit'][$key])) { $markset[$key]['leavepoint'] = $markset[$key]['maxcredit'] > $userInfo['credit'][$key]['pingnum'] ? abs($markset[$key]['maxcredit'] - $userInfo['credit'][$key]['pingnum']) : 0; } else { $markset[$key]['leavepoint'] = $markset[$key]['maxcredit']; } } list($this->markable, $this->markset, $this->userCreditInfo) = array($markable, $markset, $userInfo['credit']); }  function _initPostData($tid, $pids = array()) { $postData = array(); $hasTopic = false;  foreach ($pids as $k => $v) { is_numeric($v) or $hasTopic = true; } $pw_tmsgs = GetTtable($tid); $threadInfo = $this->db->get_one( "SELECT t.tid,t.fid,t.author,t.authorid,t.postdate,t.subject,t.anonymous,t.ptable,tm.content,tm.ifmark 
				FROM pw_threads t 
				LEFT JOIN $pw_tmsgs tm USING(tid) 
				WHERE t.tid=" . S::sqlEscape($tid) ); if (!is_array($threadInfo)) return false; $GLOBALS['subject'] = $threadInfo['subject']; $hasTopic && $postData['tpc'] = $threadInfo; L::loadClass('forum', 'forum', false); $this->fid = $threadInfo['fid']; $this->tid = $tid; $this->forum = new PwForum($this->fid);  if ($pids) { $pw_posts = GetPtable($threadInfo['ptable']); $query = $this->db->query( "SELECT pid,tid,fid,author,authorid,postdate,subject,ifmark,anonymous,content 
					FROM $pw_posts 
					WHERE pid IN(" . S::sqlImplode($pids) . ") AND tid=" . S::sqlEscape($tid)); while ($rt = $this->db->fetch_array($query)) { $rt['subject'] or $rt['subject'] = 'RE:'.$threadInfo['subject']; $postData[$rt['pid']] = $rt; } } $this->postData = $postData;  }  function sendMessage($receiver,$title,$content){ global $winduid,$windid; $messageInfo = array( 'create_uid'=>$winduid, 'create_username'=>$windid, 'title'=>$title, 'content'=>$content ); M::sendMessage( $winduid, array($receiver), $messageInfo, 'sms_ratescore', 'sms_rate' ); }  function addPost($tid,$content){ global $timestamp; $tpcarray = $this->db->get_one("SELECT tid,fid,locked,subject,ifcheck,postdate,lastpost,ptable,author,replies,type,ifshield,anonymous,tpcstatus FROM pw_threads WHERE tid=" .S::sqlEscape($tid)); L::loadClass('forum', 'forum', false); L::loadClass('post', 'forum', false); if($tpcarray['tid'] != $tid) return false; $tpcarray['openIndex'] = getstatus($tpcarray['tpcstatus'], 2); $pwforum = new PwForum($tpcarray['fid']); $pwpost = new PwPost($pwforum); if(!$pwforum->foruminfo['allowrp'] && !$pwpost->admincheck && $GLOBALS['_G']['allowrp'] == 0){ return 'reply_group_right'; }elseif ($pwforum->forumset['lock']&& !$pwpost->isGM && $timestamp - $tpcarray['postdate'] > $pwforum->forumset['lock'] * 86400 && !pwRights($pwpost->isBM,'replylock')) {  return 'forum_locked'; } elseif (!$pwpost->isGM && !$tpcarray['ifcheck'] && !pwRights($pwpost->isBM,'viewcheck')) { return 'reply_ifcheck'; } elseif(!$pwpost->isGM && $tpcarray['locked']%3<>0 && !pwRights($pwpost->isBM,'replylock')) { return 'reply_lockatc'; } else { L::loadClass('replypost', 'forum', false); $replypost = new replyPost($pwpost); $replypost->setTpc($tpcarray); $pwpost->errMode = true; $replypost->check(); if ($pwpost->errMsg && $msg = reset($pwpost->errMsg)) { return $msg; } require_once(R_P . 'require/bbscode.php'); $postdata = new replyPostData($pwpost);    $replypost->setTpc($tpcarray); $postdata->setContent($content); $postdata->conentCheck(); $replypost->execute($postdata); return true; } } function checkReplyRight($tid) { global $isGM,$winddb,$isBM,$timestamp; $threadService = L::loadClass('threads', 'forum'); L::loadClass('forum', 'forum', false); $read = $threadService->getByThreadId($tid); $pwforum = new PwForum($read['fid']); $forumset =& $pwforum->forumset; $tpc_locked = $read['locked']%3<>0 ? 1 : 0; $admincheck = ($isGM || $isBM) ? 1 : 0; if (getstatus($read['tpcstatus'], 7)) { $robbuildService = L::loadClass('RobBuild', 'forum');  $robbuild = $robbuildService->getByTid($tid); if ($robbuild['starttime'] > $timestamp) return false; } $isAuthStatus = $admincheck || (!$forumset['auth_allowrp'] || $pwforum->authStatus($winddb['userstatus'],$forumset['auth_logicalmethod']) === true); if ($isAuthStatus && (!$tpc_locked || $SYSTEM['replylock']) && ($admincheck || $pwforum->allowreply($winddb, $groupid))) { return true; } return false; }  function checkReply($tid) { global $timestamp,$groupid,$winddb,$winduid,$_time; $this->hours =& $_time['hours']; $tpcarray = $this->db->get_one("SELECT tid,fid,locked,ifcheck,postdate,ptable,tpcstatus FROM pw_threads WHERE tid=" . S::sqlEscape($tid)); if (empty($tpcarray)) { return false; } L::loadClass('forum', 'forum', false); L::loadClass('post', 'forum', false); $pwforum = new PwForum($tpcarray['fid']); $pwpost = new PwPost($pwforum); if (getstatus($tpcarray['tpcstatus'], 7)) { $robbuildService = L::loadClass('RobBuild', 'forum');  $robbuild = $robbuildService->getByTid($tid); if ($robbuild['starttime'] > $timestamp) return false; } if(!$pwforum->foruminfo['allowrp'] && !$pwpost->admincheck && $GLOBALS['_G']['allowrp'] == 0){ return 'reply_group_right'; }elseif ($pwforum->forumset['lock']&& !$pwpost->isGM && $timestamp - $tpcarray['postdate'] > $pwforum->forumset['lock'] * 86400 && !pwRights($pwpost->isBM,'replylock')) { return 'forum_locked'; } elseif (!$pwpost->isGM && !$tpcarray['ifcheck'] && !pwRights($pwpost->isBM,'viewcheck')) { return 'reply_ifcheck'; } elseif (!$pwpost->isGM && $tpcarray['locked']%3<>0 && !pwRights($pwpost->isBM,'replylock')) { return 'reply_lockatc'; } elseif (!$pwpost->isGM && !$pwpost->forum->allowtime($this->hours) && !pwRights($pwpost->isBM, 'allowtime')) { return 'forum_allowtime'; } else { if ($groupid == 6 || getstatus($winddb['userstatus'], PW_USERSTATUS_BANUSER)) { $bandb = array(); $query = $this->db->query("SELECT * FROM pw_banuser WHERE uid=".S::sqlEscape($winduid)); while ($rt = $this->db->fetch_array($query)) { if ($rt['fid'] == 0 || $rt['fid'] == $tpcarray['fid']) { $bandb[$rt['fid']] = $rt; } } if ($bandb) return 'ban_info3'; } L::loadClass('replypost', 'forum', false); $replypost = new replyPost($pwpost); $replypost->setTpc($tpcarray); $pwpost->errMode = true; $replypost->check(); if ($pwpost->errMsg && $msg = reset($pwpost->errMsg)) { return $msg; } return true; } } function pingCheck($checkType = '') { global $db_pingtime,$timestamp,$gp_gptype,$winduid,$windid,$manager,$_G; $pids = array_keys($this->postData); foreach ($pids as $k => $v) { !is_numeric($v) && $pids[$k] = 0; } foreach ($this->postData as $pid => $post) { if ($db_pingtime && $timestamp - $post['postdate'] > $db_pingtime*3600 && $gp_gptype != 'system') { return 'pingtime_over'; } if ($winduid == $post['authorid'] && $checkType == 1 && !CkInArray($windid,$manager)) { return 'masigle_manager'; } } if ($checkType == '1' && $_G['markable'] < 2 && $this->isPing($this->tid, $pids)) { return 'no_markagain'; } if ($checkType == '2' && $this->isNotPing($this->tid, $pids)) { return 'have_not_showping'; } return true; } function isPing($tid, $pids) { $pinglog = $this->pingList($tid, $pids); return !empty($pinglog); } function isNotPing($tid, $pids) { $pinglog = $this->pingList($tid, $pids); return count($pids) != count($pinglog); } function pingList($tid, $pids) { global $windid; if (empty($tid) || empty($pids)) { return array(); } $array = array(); $query = $this->db->query( "SELECT pid FROM `pw_pinglog` 
				WHERE tid=" . S::sqlEscape($tid) . " 
					AND pid IN(" . S::sqlImplode($pids) . ") 
					AND pinger=" . S::sqlEscape($windid) . ' GROUP BY pid' ); while ($row = $this->db->fetch_array($query)) { $array[$rt['pid']] = 1; } return $array; } function update_markinfo($tid, $pid) { $perpage = 10; $pid = intval($pid); $creditnames = pwCreditNames(); $whereStr = " tid=" . S::sqlEscape($tid) . " AND pid=" . S::sqlEscape($pid) . " AND ifhide=0 "; $count = 0; $creditCount = array(); $query = $this->db->query("SELECT COUNT(*) AS count,name,SUM(point) AS sum FROM pw_pinglog WHERE $whereStr GROUP BY name"); while ($rt = $this->db->fetch_array($query)) { $count += $rt['count']; if (isset($creditnames[$rt['name']])) { $creditCount[$rt['name']] += $rt['sum']; } elseif (in_array($rt['name'], $creditnames)) { $key = array_search($rt['name'], $creditnames); $creditCount[$key] += $rt['sum']; } } $markInfo = ''; if ($count) { $query = $this->db->query("SELECT id FROM pw_pinglog WHERE $whereStr ORDER BY id DESC LIMIT 0,$perpage"); $ids = array(); while ($rt = $this->db->fetch_array($query)) { $ids[] = $rt['id']; } $markInfo = $count . ":" . implode(",", $ids); if ($creditCount) { $tmp = array(); foreach ($creditCount as $key => $value) { $tmp[] = $key . '=' . $value; } $markInfo .= ':' . implode(',', $tmp); } } if ($pid == 0) { $pw_tmsgs = GetTtable($tid);  pwQuery::update($pw_tmsgs, 'tid=:tid', array($tid), array('ifmark'=>$markInfo)); } else {  pwQuery::update(GetPtable("N",$tid),'pid=:pid',array($pid),array('ifmark'=>$markInfo)); } return $markInfo; } function getPingLogs($tid, $pingIdArr,$page=null) { if (empty($pingIdArr)) return array(); global $db,$fid; static $creditnames; is_array($creditnames) or $creditnames = pwCreditNames(); $pingIds = array(); $pingLogs = array(); if($page){ $page = intval($page); if($page < 1) $page = 1; } foreach ($pingIdArr as $pid => $markInfo) { list($count, $ids, $creditCount) = explode(":", $markInfo); $pingLogs[$pid]['count'] = $count; $pingLogs[$pid]['creditCount'] = $this->parseCreditCount($creditCount); $pingIds = array_merge($pingIds, explode(",", $ids)); $page && $pingLogs[$pid]['pages'] = numofpage($count, $page, ceil($count/10), "apps.php?q=ajax&a=pingpage&tid=$tid&count=$count&pid=$pid&fid=$fid&", null, 'ajaxPingcp'); } if (!count($pingIds) && !$page) return array(); $query = $this->db->query("SELECT a.*,b.uid FROM pw_pinglog a LEFT JOIN pw_members b ON a.pinger=b.username WHERE a.id IN (" . S::sqlImplode($pingIds) . ")"); while ($rt = $this->db->fetch_array($query)) { $rt['pid'] = $rt['pid'] ? $rt['pid'] : 'tpc'; list($rt['pingtime'],$rt['pingdate']) = getLastDate($rt['pingdate']); $rt['record'] = $rt['record'] ? $rt['record'] : "-"; if ($rt['point'] > 0) $rt['point'] = "+" . $rt['point'];   isset($creditnames[$rt['name']]) && $rt['name'] = $creditnames[$rt['name']]; $pingLogs[$rt['pid']]['data'][$rt['id']] = $rt; } foreach ($pingLogs as $pid => $data) { if (is_array($pingLogs[$pid]['data'])) krsort($pingLogs[$pid]['data']); } return $pingLogs; } function parseCreditCount($creditCount) { if (!$creditCount) return array(); $arr = explode(',', $creditCount); $array = array(); foreach ($arr as $value) { list($cType, $cValue) = explode('=', $value); $array[$cType] = ($cValue > 0 ? '+' : '') . $cValue; } return $array; } }!defined('P_W') && exit('Forbidden');  class PW_Rate { var $_cache = TRUE;   function getRateConfig($typeId, $id) { $id = intval($id); if ($id < 1) { return null; } $rateConfigDb = $this->_getRateConfigDB(); return ($this->_cache) ? $this->_get_RateConfigCache($typeId, $id) : $rateConfigDb->get($id); }  function addRateConfig($fieldData) { $fieldData = $this->_checkRateConfig($fieldData); if ($fieldData === FALSE) { return null; } $rateConfigDB = $this->_getRateConfigDB(); $result = $rateConfigDB->add($fieldData); if ($this->_cache && $result) { $this->_set_RateConfigCache(); } return $result; } function _checkRateConfig($fieldData) { $fieldData['title'] = trim($fieldData['title']); $fieldData['icon'] = trim($fieldData['icon']); $fieldData['isopen'] = intval($fieldData['isopen']);  $fieldData['typeid'] = intval($fieldData['typeid']);  if ($fieldData['title'] == "" || $fieldData['icon'] == "" || !in_array($fieldData['typeid'], $this->_getRateType()) || !in_array($fieldData['isopen'], array( 0, 1 ))) { return FALSE; } $fieldData['creditset'] = intval($fieldData['creditset']);  $fieldData['voternum'] = intval($fieldData['voternum']);  $fieldData['authornum'] = intval($fieldData['authornum']);  if ($fieldData['voternum'] > 10 || $fieldData['voternum'] < - 10 || $fieldData['authornum'] > 10 || $fieldData['authornum'] < - 10) { return FALSE; } $fieldData['creator'] = trim($fieldData['creator']); $fieldData['updater'] = trim($fieldData['updater']); $rateConfigDB = $this->_getRateConfigDB(); if (!$this->_isAllowFields($fieldData, $rateConfigDB->getStruct())) { return FALSE; } $fieldData['created_at'] = $fieldData['update_at'] = time(); return $fieldData; } function _isAllowFields($sourceFields, $allowFields) { foreach($sourceFields as $key => $value) { if (!in_array($key, $allowFields)) { return FALSE; } } return TRUE; }  function updateRateConfig($fieldData, $id) { $id = intval($id); $rateConfigDB = $this->_getRateConfigDB(); if ($id < 1 || !$this->_isAllowFields($fieldData, $rateConfigDB->getStruct())) { return null; } $result = $rateConfigDB->update($fieldData, $id); if ($this->_cache && $result) { $this->_set_RateConfigCache(); } return $result; }  function deleteRateConfig($id) { $id = intval($id); if ($id < 1) { return null; } $rateConfigDB = $this->_getRateConfigDB(); $result = $rateConfigDB->delete($id); if ($this->_cache && $result) { $this->_set_RateConfigCache(); } return $result; }  function getsRateConfigByTypeId($typeId) { $typeId = intval($typeId); if ($typeId < 1) { return null; } $rateConfigDB = $this->_getRateConfigDB();  if (!$this->_cache || !$rateConfigs = $this->_get_RateConfigCache($typeId)) { $rateConfigs = $rateConfigDB->getsByTypeId($typeId); } if (!$rateConfigs) { return null; } $tmp = array(); foreach($rateConfigs as $config) { $config['tips'] = $this->_buildTips($config); $tmp[] = $config; } return $tmp; } function _buildTips($config) { $creditNames = $this->getCreditDefaultMap(); $creditName = $creditNames[$config['creditset']]; $tips = array(); $tips[] = "评价者" . $creditName . $this->_setPrefix($config['voternum']); $tips[] = "作者" . $creditName . $this->_setPrefix($config['authornum']); return implode("，", $tips); } function _setPrefix($value) { return ($value > 0) ? "+" . $value : $value; }  function addRate($userId, $objectId, $optionId, $typeId, $ip, $anonymity = FALSE) {    global $credit; if (!$authorId = $this->_checkObjectByTypeId($typeId, $objectId)) { return null; }  if (!$this->getRateResultByOptionId($optionId, $objectId)) { $fieldData = array( 'objectid' => $objectId, 'optionid' => $optionId, 'typeid' => $typeId, 'num' => 1 ); $this->addRateResult($fieldData); } else { $this->updateRateResultByOptionId($optionId, $objectId); } $fieldData = array( 'objectid' => $objectId, 'optionid' => $optionId, 'typeid' => $typeId, 'uid' => $userId, 'created_at' => time(), 'ip' => $ip ); $fieldData = $this->_checkRate($fieldData, $anonymity); if ($fieldData === FALSE) { return null; } $rateDB = $this->_getRateDB(); $rateDB->add($fieldData);   if (!$this->_cache || !$config = $this->_get_RateConfigCache($typeId, $optionId)) { $config = $this->getRateConfig($typeId, $optionId); } require_once S::escapePath(R_P . "require/credit.php"); if ($config['creditset'] < 0) { $creditMap = array_flip($this->_getCreditMap()); $cType = $creditMap[$config['creditset']]; } else { $cType = $config['creditset']; } (!$anonymity) && $credit->set($userId, $cType, $config['voternum']); $credit->set($authorId, $cType, $config['authornum']);  $this->_addRateForHot($objectId, $typeId, $optionId); return $this->_buildTips($config); }   function _getRateTypesForHot($typeId, $optionId = FALSE) { $configs = $this->getsRateConfigByTypeId($typeId); $prefix = ($typeId == 1) ? "rateThread_" : (($typeId == 2) ? "rateDiary_" : "ratePicture_"); $newConfigs = $actions = array(); foreach($configs as $config) { $ratePrefix = $prefix . $config['id']; $actions[$config['id']] = $ratePrefix; $newConfigs[$ratePrefix] = $config['title']; } return ($optionId) ? $actions[$optionId] : $newConfigs; } function _addRateForHot($objectId, $typeId, $optionId) { $action = $this->_getRateTypesForHot($typeId, $optionId); require_once (R_P . 'require/functions.php'); updateDatanalyse($objectId, $action, 1); }  function getRateThreadHotTypes() { return $this->_getRateTypesForHot(1); }  function getRateDiaryHotTypes() { return $this->_getRateTypesForHot(2); }  function getRatePictureHotTypes() { return $this->_getRateTypesForHot(3); }  function _checkRate($fieldData, $anonymity) { $fieldData['objectid'] = intval($fieldData['objectid']); $fieldData['optionid'] = intval($fieldData['optionid']); $fieldData['typeid'] = intval($fieldData['typeid']); $fieldData['uid'] = intval($fieldData['uid']); if (!$anonymity && $fieldData['uid'] < 0) { return FALSE; } $rateDB = $this->_getRateDB(); if ($fieldData['objectid'] < 0 || !in_array($fieldData['typeid'], $this->_getRateType()) || $fieldData['optionid'] < 0 || !$this->_isAllowFields($fieldData, $rateDB->getStruct())) { return FALSE; } $fieldData['created_at'] = time(); return $fieldData; }  function getsRateByUserId($userId, $objectId, $typeId) { $userId = intval($userId); $objectId = intval($objectId); $typeId = intval($typeId); if ($typeId < 1 || $userId < 1 || $objectId < 1) { return null; } $rateDB = $this->_getRateDB(); return $rateDB->getsByUserId($userId, $objectId, $typeId); }  function getRateByWeek($typeId) { $typeId = intval($typeId); if ($typeId < 1) { return null; } $rateDB = $this->_getRateDB(); $RateResult = $rateDB->getFromTmpTableByWeek($typeId);  if (!$RateResult) { return null; } $tmp = array(); foreach($RateResult as $result) {  $result['objectInfo'] = $this->_getObjectByTypeId($typeId, $result['objectid']); $tmp[$result['optionid']] = array_merge($result['objectInfo'], $result); } return $tmp; }  function _getObjectByTypeId($typeId, $objectId) { switch ($typeId) { case 1: return $this->_getThreadById($objectId); break; case 2: return $this->_getDiaryByById($objectId); break; case 3: return $this->_getPhotoById($objectId); break; default: return array(); } return array(); } function _getThreadById($tid) { $rateDB = $this->_getRateDB(); $thread = $rateDB->_db->get_one("SELECT * FROM pw_threads WHERE tid={$tid}"); if (!$thread) { return array(); } $result = array(); $result['title'] = $thread['subject']; $result['href'] = "/read.php?tid=" . $tid; $result['author'] = $thread['author']; $result['authorUrl'] = "/".USER_URL. $thread['authorid'];  return $result; } function _getDiaryByById($did) { $rateDB = $this->_getRateDB(); $diary = $rateDB->_db->get_one("SELECT * FROM pw_diary WHERE did={$did}"); if (!$diary) { return array(); } $result = array(); $result['title'] = $diary['subject']; $result['href'] = "/apps.php?q=diary&u=" . $diary['uid'] . "&did=" . $did; $result['author'] = $diary['username']; $result['authorUrl'] = "/".USER_URL. $diary['uid'];  return $result; } function _getPhotoById($pid) { $rateDB = $this->_getRateDB(); $photo = $rateDB->_db->get_one("SELECT * FROM pw_cnphoto WHERE pid={$pid}"); if (!$photo) { return array(); } $album = $rateDB->_db->get_one("SELECT * FROM pw_cnalbum WHERE aid=" . $photo['aid']); $result = array(); $result['title'] = (isset($photo['pintro']) && trim($photo['pintro']) != "") ? $photo['pintro'] : '暂无描述';  $result['href'] = "/apps.php?q=photos&space=1&u=" . $album['ownerid'] . "&a=view&pid=" . $pid; $result['author'] = $photo['uploader']; $result['authorUrl'] = "/".USER_URL. $album['ownerid']; return $result; } function _checkObjectByTypeId($typeId, $objectId) { switch ($typeId) { case 1: return $this->_checkThreadById($objectId); break; case 2: return $this->_checkDiaryByById($objectId); break; case 3: return $this->_checkPhotoById($objectId); break; default: return FALSE; } return TRUE; } function _checkThreadById($tid) { $rateDB = $this->_getRateDB(); $thread = $rateDB->_db->get_one("SELECT * FROM pw_threads WHERE tid={$tid}"); if (!$thread || !isset($thread['authorid'])) { return FALSE; } return $thread['authorid']; } function _checkDiaryByById($did) { $rateDB = $this->_getRateDB(); $diary = $rateDB->_db->get_one("SELECT * FROM pw_diary WHERE did={$did}"); if (!$diary || !isset($diary['uid'])) { return FALSE; } return $diary['uid']; } function _checkPhotoById($pid) { $rateDB = $this->_getRateDB(); $photo = $rateDB->_db->get_one("SELECT * FROM pw_cnphoto WHERE pid={$pid}"); if (!$photo) { return FALSE; } $album = $rateDB->_db->get_one("SELECT * FROM pw_cnalbum WHERE aid=" . $photo['aid']); if (!$album || !isset($album['ownerid'])) { return FALSE; } return $album['ownerid']; } function addConfigPower($powerData, $groupData) { setConfig('db_ratepower', serialize($powerData)); setConfig('db_rategroup', serialize($groupData)); updatecache_c(); } function getUserGroupLevel() { $rateDB = $this->_getRateDB(); $query = $rateDB->_db->query("SELECT gid,gptype,grouptitle,groupimg,grouppost FROM pw_usergroups ORDER BY grouppost,gid"); $userGroups = $rateDB->_getAllResultFromQuery($query); $tmp = array(); foreach($userGroups as $group) { if ($group['gptype'] == 'default' && $group['gid'] != 2) { continue; } if ($group['gptype'] == 'system' && $group['gid'] == 3) { continue; } $group['defaultTimes'] = ($group['gptype'] == 'member' && $group['gid'] == 8) ? 5 : 20; $tmp[$group['gptype']][] = $group; }  $groups = array(); $groups['member'] = $tmp['member']; $groups['system'] = $tmp['system']; $groups['special'] = $tmp['special']; $groups['default'] = $tmp['default']; return $groups; } function _getBaseDB() { require_once S::escapePath(dirname(__FILE__) . "/base/basedb.php"); return new BaseDB(); }   function addRateResult($fieldData) { $fieldData = $this->_checkRateResult($fieldData); if ($fieldData === FALSE) { return null; } $rateResultDB = $this->_getRateResultDB(); return $rateResultDB->add($fieldData); } function _checkRateResult($fieldData) { $fieldData['objectid'] = intval($fieldData['objectid']); $fieldData['optionid'] = intval($fieldData['optionid']); $fieldData['typeid'] = intval($fieldData['typeid']); if ($fieldData['objectid'] < 1 || $fieldData['optionid'] < 1 || !in_array($fieldData['typeid'], $this->_getRateType())) { return FALSE; } $fieldData['num'] = 1; return $fieldData; } function _getRateType() { return array( 1, 2, 3 ); }  function getRateResultByOptionId($optionId, $objectId) { $objectId = intval($objectId); $optionId = intval($optionId); if ($optionId < 1 || $objectId < 1) { return null; } $rateResultDB = $this->_getRateResultDB(); return $rateResultDB->getByOptionId($optionId, $objectId); }  function updateRateResultByOptionId($optionId, $objectId) { $objectId = intval($objectId); $optionId = intval($optionId); if ($optionId < 1 || $objectId < 1) { return null; } $rateResultDB = $this->_getRateResultDB(); return $rateResultDB->updateByOptionId($optionId, $objectId); }  function getRateResultByTypeId($typeId, $objectId) { $typeId = intval($typeId); $objectId = intval($objectId); if ($typeId < 1 || $objectId < 1) { return null; } $tmp = array(); $total = 0;  $rateResultDB = $this->_getRateResultDB(); $rateResults = $rateResultDB->getByTypeId($typeId, $objectId); if (!$rateResults) { return array( $tmp, $total ); } foreach($rateResults as $result) { $total += $result['num']; $tmp[$result['optionid']] = $result; } return array( $tmp, $total ); }  function getCreditDefaultMap($creditKey = null) { $map = $this->_getCreditMap(); $creditNames = pwCreditNames(); $tmp = array(); foreach($creditNames as $key => $value) { if (in_array($key, array_keys($map))) { $tmp[$map[$key]] = $value; continue; } $tmp[$key] = $value; } return (array_key_exists($creditKey, $tmp)) ? $tmp[$creditKey] : $tmp; } function _getCreditMap() { return array( "money" => "-1", "rvrc" => "-2", "credit" => "-3", "currency" => "-4" ); }  function _set_RateConfigCache() { $rateConfigDB = $this->_getRateConfigDB(); $configs = $rateConfigDB->gets(); if (!$configs) { return null; } $tmp = array(); foreach($configs as $config) { $tmp[$config['typeid']][] = $config; }  $result = serialize($tmp); pwCache::setData($this->_getReteConfigFilePath(), $result, false, 'w'); return $result; }  function _get_RateConfigCache($typeId = FALSE, $optionId = FALSE) { if (!file_exists($this->_getReteConfigFilePath()) || !$result = readover($this->_getReteConfigFilePath())) { $result = $this->_set_RateConfigCache(); } $rateConfigs = unserialize($result); if (!$rateConfigs) { return FALSE; }  if ($optionId && $typeId && isset($rateConfigs[$typeId])) { foreach($rateConfigs[$typeId] as $config) { if ($config['id'] == $optionId) { return $config; } } }  if (isset($rateConfigs[$typeId]) && in_array($typeId, $this->_getRateType())) { return $rateConfigs[$typeId]; } return $rateConfigs; } function _getReteConfigFilePath() { return D_P . 'data/bbscache/rate_config.php'; }  function countByUserId($userId) { if (intval($userId) < 1) { return -1; } $rateDB = $this->_getRateDB(); return $rateDB->countByUserId($userId); } function countByIp($ip) { if ($ip == "") { return -1; } $rateDB = $this->_getRateDB(); return $rateDB->countByIp($ip); } function getsByIp($ip, $objectId, $typeId) { $rateDB = $this->_getRateDB(); return $rateDB->getsByIp($ip, $objectId, $typeId); }  function getWeekData($typeId, $hotSource = true) { if ($hotSource) { return $this->getWeekResultHtmlFromHot($typeId); } return $this->getRateByWeek($typeId); } function getWeekResultHtmlFromHot($typeId) { $datanalyse = $this->_getDatanalyseService(); $result = $datanalyse->getDatanalyseForRateByType($typeId); if (!$result) { return ''; } $tmp = array(); foreach($result as $objectId => $object) { $info = array(); $info['title'] = $object['title']; $info['href'] = "/" . $object['url']; $info['author'] = $object['author']; $info['authorUrl'] = "/u.php?username=" . $object['author']; $optionId = substr($object['action'], strrpos($object['action'], "_") + 1); $info['objectid'] = $objectId; $info['optionid'] = $optionId; $info['typeid'] = $typeId; $tmp[$optionId]['objectInfo'] = $info; } return $tmp; } function _getDatanalyseService() { L::loadClass('datanalyse','datanalyse',false); return new Datanalyse(); }  function _getRateConfigDB() { return L::loadDB('RateConfig', 'rate'); } function _getRateDB() { return L::loadDB('Rate', 'rate'); } function _getRateResultDB() { return L::loadDB('RateResult', 'rate'); } } ! defined ( 'P_W' ) && exit ( 'Forbidden' ); class PW_RateConfigDB extends BaseDB { var $_tableName = "pw_rateconfig"; function add($fieldData) { $this->_db->update ( "INSERT INTO " . $this->_tableName . " SET " . $this->_getUpdateSqlString ( $fieldData ) ); return $this->_db->insert_id (); } function update($fieldData, $id) { $this->_db->update ( "UPDATE " . $this->_tableName . " SET " . $this->_getUpdateSqlString ( $fieldData ) . "WHERE id=" . $this->_addSlashes ( $id ) . " LIMIT 1" ); return $this->_db->affected_rows (); } function delete($id) { $this->_db->update ( "DELETE FROM " . $this->_tableName . " WHERE id=" . $this->_addSlashes ( $id ) . " LIMIT 1" ); return $this->_db->affected_rows (); } function get($id) { return $this->_db->get_one ( "SELECT * FROM " . $this->_tableName . " WHERE id=" . $this->_addSlashes ( $id ) . " LIMIT 1" ); } function gets() { $query = $this->_db->query ( "SELECT * FROM " . $this->_tableName ); return $this->_getAllResultFromQuery ( $query ); }  function getsByTypeId($typeId) { $query = $this->_db->query ( "SELECT * FROM " . $this->_tableName . " WHERE typeid=" . $typeId ); return $this->_getAllResultFromQuery ( $query ); } function getStruct() { return array ('id', 'title', 'icon', 'isopen', 'isdefault', "typeid", "creditset", "voternum", "authornum", "creator", "created_at", "updater", "update_at" ); } } ! defined ( 'P_W' ) && exit ( 'Forbidden' ); class PW_RateDB extends BaseDB { var $_tableName = "pw_rate";  function add($fieldData) { $this->_db->update ( "INSERT INTO " . $this->_tableName . " SET " . $this->_getUpdateSqlString ( $fieldData ) ); return $this->_db->insert_id (); }  function getsByUserId($userId, $objectId, $typeId) { return $this->_db->get_one ( "SELECT * FROM " . $this->_tableName . " WHERE typeid=" . $typeId . " AND objectid=" . $objectId . " and uid=" . $userId ); } function getsByIp($ip, $objectId, $typeId) { return $this->_db->get_one ( "SELECT * FROM " . $this->_tableName . " WHERE typeid=" . $typeId . " AND objectid=" . $objectId . " and uid=0 and ip='" . $ip . "'" ); } function countByUserId($userId) { $today = explode ( ",", date ( "Y,m,d", time () ) ); $created_at = mktime ( 0, 0, 0, $today [1], $today [2], $today [0] ); $result = $this->_db->get_one ( "SELECT COUNT(*) AS total FROM " . $this->_tableName . " WHERE uid=" . $userId . " AND created_at>" . $created_at . " LIMIT 1" ); return $result ['total']; } function countByIp($ip) { $today = explode ( ",", date ( "Y,m,d", time () ) ); $created_at = mktime ( 0, 0, 0, $today [1], $today [2], $today [0] ); $result = $this->_db->get_one ( "SELECT COUNT(*) AS total FROM " . $this->_tableName . " WHERE uid=0 AND created_at>" . $created_at . " AND ip='" . $ip . "'  LIMIT 1" ); return $result ['total']; }  function getByWeek($typeId) { $beforeWeek = strtotime ( "-1 week" ); $sql = "select *,max(result.total) as max from (SELECT optionid,objectid,COUNT(*) AS total FROM " . $this->_tableName . " WHERE typeid=" . $typeId . " AND created_at>" . $beforeWeek . " GROUP BY optionid,objectid ORDER BY null) AS result GROUP BY optionid ORDER BY null"; $query = $this->_db->query ( $sql ); return $this->_getAllResultFromQuery ( $query ); } function getFromTmpTableByWeek($typeId) { $beforeWeek = strtotime ( "-1 week" ); $mysql = $this->_db; $mysql->query ( "CREATE TEMPORARY TABLE tmp_rate_table (optionid int(10) NOT NULL,objectid int NOT NULL,total int NOT NULL)" );  $mysql->query ( "INSERT INTO tmp_rate_table SELECT optionid,objectid,COUNT(*) AS total FROM " . $this->_tableName . " WHERE typeid=" . $typeId . " and created_at>" . $beforeWeek . " GROUP BY optionid,objectid ORDER BY null" ); $query = $mysql->query ( "SELECT *,MAX(total) AS max FROM tmp_rate_table GROUP BY optionid ORDER BY null" );  $mysql->query ( "DROP TABLE tmp_rate_table" ); $result = $this->_getAllResultFromQuery ( $query ); return $result; } function getStruct() { return array ('objectid', 'optionid', 'typeid', 'uid', 'created_at', 'ip' ); } } ! defined ( 'P_W' ) && exit ( 'Forbidden' ); class PW_RateResultDB extends BaseDB { var $_tableName = "pw_rateresult"; function add($fieldData) { $this->_db->update ( "INSERT INTO " . $this->_tableName . " SET " . $this->_getUpdateSqlString ( $fieldData ) ); return $this->_db->insert_id (); }  function getByOptionId($optionId, $objectId) { return $this->_db->get_one ( "SELECT * FROM " . $this->_tableName . " WHERE optionid=" . $this->_addSlashes ( $optionId ) . " AND objectid=" . $this->_addSlashes ( $objectId ) . "  LIMIT 1" ); }  function updateByOptionId($optionId, $objectId) { $this->_db->update ( "UPDATE " . $this->_tableName . " SET num=num+1 WHERE optionid=" . $this->_addSlashes ( $optionId ) . " AND objectid=" . $this->_addSlashes ( $objectId ) . "  LIMIT 1" ); return $this->_db->affected_rows (); }  function getByTypeId($typeId, $objectId) { $query = $this->_db->query ( "SELECT * FROM " . $this->_tableName . " WHERE typeid=" . $this->_addSlashes ( $typeId ) . " AND objectid=" . $this->_addSlashes ( $objectId ) ); return $this->_getAllResultFromQuery ( $query ); } } ! function_exists ( 'readover' ) && exit ( 'Forbidden' );  class PW_AutoJob { var $_db = null; var $_hour = 3600; var $_timestamp = null; var $_cache = true; function PW_AutoJob() { global $db, $timestamp; $this->_db = & $db; $this->_timestamp = $timestamp; } function run($userid, $groupid) { return $this->jobAutoController ( $userid, $groupid ); } function jobAutoController($userid, $groupid) { $userid = intval ( $userid ); $groupid = intval ( $groupid ); if ($groupid < 1 || $userid < 1) { return; } if (! $jobLists = $this->_jobAutoFilterHandler ( $userid, $groupid )) { return; } $current = $this->_timestamp; foreach ( $jobLists as $job ) { $this->_jobAutoCreateHandler ( $userid, $job, $current ); } } function _jobAutoFilterHandler($userid, $groupid) { $jobs = $this->getJobsAuto (); if (! $jobs) { return false; } $current = $this->_timestamp; $jobLists = $jobIds = $periods = $preposes = array (); foreach ( $jobs as $job ) { if ($job ['isopen'] == 0) { continue; } if ((isset ( $job ['endtime'] ) && $job ['endtime'] != 0 && $job ['endtime'] < $current)) { continue; } if ((isset ( $job ['starttime'] ) && $job ['starttime'] != 0 && $job ['starttime'] > $current)) { continue; } if (isset ( $job ['usergroup'] ) && $job ['usergroup'] != '') { $usergroups = explode ( ",", $job ['usergroup'] ); if (! in_array ( $groupid, $usergroups )) { continue; } } if (isset ( $job ['period'] ) && $job ['period'] > 0) { $periods [] = $job ['id']; } if (isset ( $job ['prepose'] ) && $job ['prepose'] > 0) { $preposes [$job ['prepose']] = $job ['id']; } if (isset ( $job ['number'] ) && $job ['number'] != 0) { $number = $this->countJoberByJobId ( $job ['id'] ); if ($number >= $job ['number']) { continue; } }  if (S::inArray($job['job'],array('doAuthAlipay','doAuthMobile'))) { if (!$GLOBALS['db_authstate']) return false; $userService = L::loadClass('UserService','user'); if ($job['job'] == 'doAuthAlipay' && $userService->getUserStatus($userid, PW_USERSTATUS_AUTHALIPAY)){ return false; } if ($job['job'] == 'doAuthMobile' && $userService->getUserStatus($userid, PW_USERSTATUS_AUTHMOBILE)){ return false; } } $jobLists [$job ['id']] = $job; $jobIds [] = $job ['id']; } if (! $jobLists) { return false; } $joins = $this->getJobersByJobIds ( $userid, $jobIds ); if ($joins) { foreach ( $joins as $join ) { $t_job = array (); $t_job = $jobLists [$join ['jobid']]; if (in_array ( $join ['jobid'], $periods )) { if ($join ['status'] >= 3 && $join ['total'] > 0) { if ($join ['next'] < $current) { $this->_jobAutoAgainHandler ( $userid, $t_job, $current ); } } } unset ( $t_job ); unset ( $jobLists [$join ['jobid']] ); } } if (! $jobLists) { return false; } if ($preposes) { $joins = $this->getJobersByJobIds ( $userid, array_keys ( $preposes ) ); if ($joins) { foreach ( $joins as $join ) { if ($join ['total'] > 0) { unset ( $preposes [$join ['jobid']] ); } } } if ($preposes) { foreach ( $preposes as $jobid ) { unset ( $jobLists [$jobid] ); } } } return $jobLists; } function _jobAutoAgainHandler($userid, $job, $current) { $next = $current; if (isset ( $job ['period'] ) && $job ['period'] != 0) { $next = $current + $job ['period'] * $this->_hour; } $job ['next'] = $next ? $next : $current; $this->_againJober ( $userid, $job ['id'], $job ['next'], $current ); } function _againJober($userId, $jobId, $next, $current, $jober = array()) { $jober = $jober ? $jober : $this->getJoberByJobId ( $userId, $jobId ); if (! $jober) { return array (); } $data = array (); $data ['current'] = 1; $data ['step'] = 0; $data ['last'] = $current; $data ['next'] = $next; $data ['status'] = 0; $result = $this->updateJober ( $data, $jober ['id'] ); if ($result) { $this->increaseJobNum ( $userId ); } return $result; } function updateJober($fields, $id) { $joberDao = $this->_getJoberDao (); return $joberDao->update ( $fields, $id ); } function getJobsAuto() { if ($this->_cache) { $jobs = $this->getFileCache (); if ($jobs) { $autos = array (); foreach ( $jobs as $job ) { if ($job ['auto'] == 1) { $autos [] = $job; } } return $autos; } } $jobDao = $this->_getJobDao (); return $jobDao->getByAuto (); } function getFileCache() { if (! $this->_cache) { return array (); }  extract(pwCache::getData(S::escapePath ( $this->getCacheFileName ()), false)); $jobLists = ($jobLists) ? $jobLists : $GLOBALS ['jobLists']; if ($jobLists) { return $jobLists; } return $this->setFileCache (); } function setFileCache() { $jobDao = $this->_getJobDao (); $jobs = $jobDao->getAll (); $jobLists = "\$jobLists=" . pw_var_export ( $jobs ) . ";"; pwCache::setData ( $this->getCacheFileName (), "<?php\r\n" . $jobLists . "\r\n?>" ); return $jobs; } function _jobAutoCreateHandler($userid, $job, $current) { if (isset ( $job ['period'] ) && $job ['period'] != 0) { $next = $current + $job ['period'] * $this->_hour; $job ['next'] = $next ? $next : $current; } $this->_createJober ( $userid, $job ['id'], $job ['next'], $current ); } function _createJober($userId, $jobId, $next, $current, $jober = array()) { $jober = $jober ? $jober : $this->getJoberByJobId ( $userId, $jobId ); if ($jober) { return array (); } $data = array (); $data ['jobid'] = $jobId; $data ['userid'] = $userId; $data ['current'] = 1; $data ['step'] = 0; $data ['last'] = $current; $data ['next'] = $next; $data ['status'] = 0; $data ['creattime'] = $current; return $this->addJober ( $data ); } function getCacheFileName() { return R_P . "data/bbscache/jobs.php"; } function getJobersByJobIds($userid, $ids) { $joberDao = $this->_getJoberDao (); return $joberDao->getJobersByJobIds ( $userid, $ids ); } function addJober($fields) { $fields ['userid'] = intval ( $fields ['userid'] ); $fields ['jobid'] = intval ( $fields ['jobid'] ); if ($fields ['userid'] < 1 || $fields ['jobid'] < 1) { return null; } $joberDao = $this->_getJoberDao (); $result = $joberDao->add ( $fields ); if ($result) { $this->increaseJobNum ( $fields ['userid'] ); } return $result; } function increaseJobNum($userid) { $this->updateJobNum ( $userid ); } function updateJobNum($userid) { $jobnum = $this->countJobnum ( $userid ); ($jobnum > 0) ? $jobnum : 0; $userService = L::loadClass ( 'UserService', 'user' ); return $userService->update ( $userid, array (), array ('jobnum' => $jobnum ) ); } function countJobNum($userId) { if (! $userId) return false; $joblists = $this->getAppliedJobs ( $userId ); $joblists = $joblists ? $joblists : array (); $num = 0; foreach ( $joblists as $job ) { if ($job ['isopen'] == 0 || $job['isuserguide']) continue; $num ++; } return $num; } function getAppliedJobs($userid) { $joberDao = $this->_getJoberDao (); $jobers = $joberDao->getAppliedJobs ( $userid ); if (! $jobers) { return array (); } return $this->buildJobListByIds ( $jobers ); } function buildJobListByIds($jobers) { if (! $jobers) { return array (); } $jobIds = $tmp = array (); foreach ( $jobers as $job ) { $jobIds [] = $job ['jobid']; $tmp [$job ['jobid']] = $job; } $jobs = $this->getJobsByIds ( $jobIds ); if (! $jobs) { return array (); } $result = array (); foreach ( $jobs as $job ) { $result [] = array_merge ( $tmp [$job ['id']], $job ); } return $result; } function getJobsByIds($jobIds) { if ($this->_cache) { $jobs = $this->getFileCache (); if ($jobs) { $result = array (); foreach ( $jobs as $job ) { if (in_array ( $job ['id'], $jobIds )) { $result [] = $job; } } return $result; } } $jobDao = $this->_getJobDao (); return $jobDao->getByIds ( $jobIds ); } function getJoberByJobId($userId, $jobId) { $joberDao = $this->_getJoberDao (); return $joberDao->getByJobId ( $userId, $jobId ); } function countJoberByJobId($jobid) { $joberDao = $this->_getJoberDao (); return $joberDao->countByJobId ( $jobid ); } function _getJobDao() { $job = L::loadDB ( 'job', 'job' ); return $job; } function _getJoberDao() { $job = L::loadDB ( 'jober', 'job' ); return $job; } function _getJobDoerDao() { $job = L::loadDB ( 'jobdoer', 'job' ); return $job; } }! defined ( 'P_W' ) && exit ( 'Forbidden' ); class PW_JoberDB extends BaseDB { var $_tableName = "pw_jober"; function add($fieldData) { $this->_db->update ( "INSERT INTO " . $this->_tableName . " SET " . $this->_getUpdateSqlString ( $fieldData ) ); return $this->_db->insert_id (); } function update($fieldData, $id) { $this->_db->update ( "UPDATE " . $this->_tableName . " SET " . $this->_getUpdateSqlString ( $fieldData ) . " WHERE id=" . $this->_addSlashes ( $id ) . " LIMIT 1" ); return $this->_db->affected_rows (); } function delete($id) { $this->_db->update ( "DELETE FROM " . $this->_tableName . " WHERE id=" . $this->_addSlashes ( $id ) . " LIMIT 1" ); return $this->_db->affected_rows (); } function get($id) { $id = intval($id); if($id<1){ return null; } return $this->_db->get_one ( "SELECT * FROM " . $this->_tableName . " WHERE id=" . $this->_addSlashes ( $id ) . " LIMIT 1" ); } function getByJobId($userId,$jobId) { $userId = intval($userId); $jobId = intval($jobId); if($userId<1 || $jobId<1){ return null; } return $this->_db->get_one ( "SELECT * FROM " . $this->_tableName . " WHERE jobid=" . $this->_addSlashes ( $jobId ) . " AND userid =" . $this->_addSlashes ( $userId ) . " ORDER BY last DESC LIMIT 1" ); } function getAll() { $query = $this->_db->query ( "SELECT * FROM " . $this->_tableName ); return $this->_getAllResultFromQuery ( $query ); } function gets($offset,$limit) { $query = $this->_db->query ( "SELECT * FROM " . $this->_tableName. "  LIMIT " . $offset . "," . $limit ); return $this->_getAllResultFromQuery ( $query ); } function countByJobId($jobId){ $result = $this->_db->get_one ( "SELECT COUNT(*) AS total FROM " . $this->_tableName . " WHERE jobid=".$this->_addSlashes ( $jobId )."  LIMIT 1" ); return $result ['total']; } function getAppliedJobs($userid){ $userid = intval($userid); if($userid<1){ return null; } $query = $this->_db->query ( "SELECT * FROM " . $this->_tableName. " WHERE userid=".$this->_addSlashes ( $userid )." AND status<=2" ); return $this->_getAllResultFromQuery ( $query ); } function countAppliedJobs($userid){ $userid = intval($userid); if($userid<1){ return null; } return $this->_db->get_value ( "SELECT COUNT(*) as total FROM " . $this->_tableName. " WHERE userid=".$this->_addSlashes ( $userid )." AND status<2 LIMIT 1" ); } function getFinishJobs($userid){ $userid = intval($userid); if($userid<1){ return null; } $query = $this->_db->query ( "SELECT * FROM " . $this->_tableName. " WHERE userid=".$this->_addSlashes ( $userid )." AND total>0" ); return $this->_getAllResultFromQuery ( $query ); } function getQuitJobs($userid){ $userid = intval($userid); if($userid<1){ return null; } $query = $this->_db->query ( "SELECT * FROM " . $this->_tableName. " WHERE userid=".$this->_addSlashes ( $userid )." AND status>=4" ); return $this->_getAllResultFromQuery ( $query ); } function updateByJobId($fieldData, $jobid,$userid) { $userid = intval($userid); $jobid = intval($jobid); if($userid<1 || $jobid<1 ){ return null; } $this->_db->update ( "UPDATE " . $this->_tableName . " SET " . $this->_getUpdateSqlString ( $fieldData ) . "  WHERE jobid=" . $this->_addSlashes ( $jobid ) . " AND userid=" . $this->_addSlashes ( $userid ) . " LIMIT 1" ); return $this->_db->affected_rows (); }  function getsByJobIds($userid,$ids) { if(!is_array($ids)){ return array(); } $ids = implode(",",$ids); return $this->_db->get_one ( "SELECT * FROM " . $this->_tableName. "  WHERE jobid in(" .$ids. ") AND status <= 1 AND userid=".$this->_addSlashes ( $userid )." ORDER BY last DESC LIMIT 1" ); }  function getInProcessJobersByUserIdAndJobIds($userid, $ids) { $userid = (int) $userid; if(!S::isArray($ids) || $userid < 1) return array(); $query = $this->_db->query('SELECT * FROM ' . $this->_tableName . ' WHERE jobid IN(' . S::sqlImplode($ids) . ') AND status = 1 AND userid = ' . S::sqlEscape($userid) . ' ORDER BY last DESC'); return $this->_getAllResultFromQuery($query); } function getJobersByJobIds($userid,$ids) { $userid = intval($userid); if(!is_array($ids) || $userid<1 ){ return array(); } $ids = implode(",",$ids); $query = $this->_db->query ( "SELECT * FROM " . $this->_tableName. "  WHERE jobid in(" .$ids. ") AND userid=".$this->_addSlashes ( $userid )); return $this->_getAllResultFromQuery ( $query ); } function getJobersByJobIdAndUserId($userid,$jobid) { $userid = intval($userid); $jobid = intval($jobid); if($userid<1 || $jobid<1 ){ return null; } $query = $this->_db->query ( "SELECT * FROM " . $this->_tableName. "  WHERE jobid=" .$this->_addSlashes($jobid)." AND userid != ".$this->_addSlashes($userid)." AND total>0 LIMIT 20"); return $this->_getAllResultFromQuery ( $query ); } function countJobersByJobIdAndUserId($userid,$jobid) { $userid = intval($userid); $jobid = intval($jobid); if($userid<1 || $jobid<1 ){ return null; } $result = $this->_db->get_one ( "SELECT COUNT(*) as total FROM " . $this->_tableName. "  WHERE jobid=" .$this->_addSlashes($jobid)." AND userid != ".$this->_addSlashes($userid)." AND total>0"); return $result['total']; } } !defined('P_W') && exit('Forbidden');  class PW_Errors { var $_errors = array();  var $_logs = array();   function addError($errorInfo) { $this->_errors[] = $errorInfo; }  function addLog($logInfo) { $this->_logs[] = $logInfo; }  function writeLog($method = 'rb+') { $logFile = D_P.'data/error.log'; if (!$this->_logs) return false; $temp = pw_var_export($this->_logs); pwCache::writeover($logFile,$temp, 'rb+'); }  function checkError($jumpurl = '') { foreach ($this->_errors as $error) { $this->showError($error,$jumpurl); } }  function showError($error, $jumpurl = '') { Showmsg($error, $jumpurl); } function __destruct() { if (!defined('SHOWLOG')) return false; $this->writeLog(); } } !defined('P_W') && exit('Forbidden');  class PW_UserService {  function get($userId, $withMainFields = true, $withMemberDataFields = false, $withMemberInfoFields = false) { $userId = (int) $userId; if ($userId <= 0) return null; if (perf::checkMemcache()){ $_cacheService = Perf::gatherCache('pw_members'); return $_cacheService->getAllFieldByUserId($userId, $withMainFields, $withMemberDataFields, $withMemberInfoFields); } $membersDb = $this->_getMembersDB(); return $membersDb->getWithJoin($userId, $withMainFields, $withMemberDataFields, $withMemberInfoFields);  }  function getByUserIds($userIds) { if (!is_array($userIds) || !count($userIds)) return array(); if (perf::checkMemcache()){ $_cacheService = Perf::gatherCache('pw_members'); return $_cacheService->getMembersByUserIds($userIds); } $membersDb = $this->_getMembersDB(); return $membersDb->getUsersByUserIds($userIds); }  function getUsersWithMemberDataByUserIds($userIds) { if (!is_array($userIds) || !count($userIds)) return array(); if (perf::checkMemcache()){ $_cacheService = Perf::gatherCache('pw_members'); return $_cacheService->getAllFieldByUserIds($userIds, true, true); } $membersDb = $this->_getMembersDB(); return $membersDb->getUserInfosByUserIds($userIds); }  function getByUserName($userName, $withMainFields = true, $withMemberDataFields = false, $withMemberInfoFields = false) { $userName = trim($userName); if (!$userName) return null; $member = array(); $membersDb = $this->_getMembersDB(); $data = $membersDb->getUserByUserName($userName); if (!$data || !$data['uid']) return null; $userId = (int) $data['uid']; $withMainFields && $member = array_merge($member, $data); if ($withMemberDataFields) { $memberDataDb = $this->_getMemberDataDB(); $data = $memberDataDb->get($userId); if ($data) $member = array_merge($member, $data); } if ($withMemberInfoFields) { $memberInfoDb = $this->_getMemberInfoDB(); $data = $memberInfoDb->get($userId); if ($data) $member = array_merge($member, $data); } return $member ? $member : null; }  function getByUserNames($userNames) { if (!is_array($userNames) || !count($userNames)) return array(); $membersDb = $this->_getMembersDB(); return $membersDb->getUsersByUserNames($userNames); }  function getUserIdByUserName($userName) { if (!$data = $this->getByUserName($userName)) return 0; return (int) $data['uid']; }  function getUserIdByEmail($email) { if (!$data = $this->getByEmail($email)) return 0; return (int) $data['uid']; }  function getUserNameByUserId($userId) { $userId = S::int($userId); if ($userId < 1) return false; if (perf::checkMemcache()){ $_cacheService = Perf::gatherCache('pw_members'); return $_cacheService->getUserNameByUserId($userId); } if (!$data = $this->get($userId)) return null; return $data['username']; }  function getUserNamesByUserIds($userIds) { if (!is_array($userIds) || !count($userIds)) return array(); if (perf::checkMemcache()){ $_cacheService = Perf::gatherCache('pw_members'); return $_cacheService->getUserNameByUserIds($userIds); } $userNames = array(); $members = $this->getByUserIds($userIds); foreach ($members as $member) { $member['uid'] && $userNames[$member['uid']] = $member['username']; } return $userNames; }  function getByEmail($email) { $email = trim($email); if ('' == $email) return null; $membersDb = $this->_getMembersDB(); $users = $membersDb->getUserByUserEmails(array($email)); return !empty($users) ? current($users) : null; }  function getByEmails($emails) { if (!is_array($emails) || !count($emails)) return array(); $membersDb = $this->_getMembersDB(); return $membersDb->getUserByUserEmails($emails); }  function getByGroupId($groupId) { $membersDb = $this->_getMembersDB(); return $membersDb->getUsersByGroupId($groupId); }  function getByGroupIds($groupIds) { if (!is_array($groupIds) || !count($groupIds)) return array(); $membersDb = $this->_getMembersDB(); return $membersDb->getUsersByGroupIds($groupIds); }  function getLatestNewUser() { $membersDb = $this->_getMembersDB(); $users = $membersDb->findUsersOrderByUserId(); return count($users) ? current($users) : null; }  function findLatestNewUsers($number = 10) { $number = intval($number); if ($number <= 0) return array(); $membersDb = $this->_getMembersDB(); return $membersDb->findUsersOrderByUserId($number); }  function findNotBannedNewUsers($number = 10) { $number = intval($number); if ($number <= 0) return array(); $membersDb = $this->_getMembersDB(); return $membersDb->findNotBannedUsersOrderByUserId($number); }  function count() { $membersDb = $this->_getMembersDB(); return $membersDb->_count(); }  function add($mainFields, $memberDataFields = array(), $memberInfoFields = array()) { if (!is_array($mainFields) || !count($mainFields)) return 0; if (!isset($mainFields['username']) || !isset($mainFields['password'])) return 0; if ('' == $mainFields['username'] || '' == $mainFields['password']) return 0; $membersDb = $this->_getMembersDB(); $userId = $membersDb->insert($mainFields); if (!$userId) return 0; $memberDataFields['uid'] = $userId; $memberDataDb = $this->_getMemberDataDB(); $memberDataDb->insert($memberDataFields); $this->_replaceMemberInfo($userId, $memberInfoFields, false); return $userId; }  function update($userId, $mainFields = array(), $memberDataFields = array(), $memberInfoFields = array()) { $userId = intval($userId); if ($userId <= 0) return false; $updates = 0; if (is_array($mainFields) && count($mainFields)) { $membersDb = $this->_getMembersDB(); $updates += $membersDb->update($mainFields, $userId);  } if (is_array($memberDataFields) && count($memberDataFields)) { $memberDataDb = $this->_getMemberDataDB(); $updates += $memberDataDb->update($memberDataFields, $userId); } $updates += $this->_replaceMemberInfo($userId, $memberInfoFields); return (bool) $updates; }  function updates($userIds, $mainFields = array(), $memberDataFields = array(), $memberInfoFields = array()) { if (!is_array($userIds) || !count($userIds)) return 0; $updates = 0; if (is_array($mainFields) && count($mainFields)) { $membersDb = $this->_getMembersDB(); $updates += $membersDb->updates($mainFields, $userIds);  } if (is_array($memberDataFields) && count($memberDataFields)) { $memberDataDb = $this->_getMemberDataDB(); $updates += $memberDataDb->updates($memberDataFields, $userIds); } if (is_array($memberInfoFields) && count($memberInfoFields)) { foreach ($userIds as $userId) { $updates += $this->_replaceMemberInfo($userId, $memberInfoFields); } } return $updates; } function clearUserMessage($uid){ $uid = intval($uid); if ($uid < 1) return false; $this->update($uid, array('newpm'=>0), array('newfans'=>0,'newreferto'=>0,'newnotice'=>0,'newrequest'=>0)); }  function updateByIncrement($userId, $mainFields = array(), $memberDataFields = array(), $memberInfoFields = array()) { $userId = intval($userId); if ($userId <= 0) return false; $updates = 0; if (is_array($mainFields) && count($mainFields)) { $membersDb = $this->_getMembersDB(); $updates += $membersDb->increase($userId, $mainFields); } if (is_array($memberDataFields) && count($memberDataFields)) { $memberDataDb = $this->_getMemberDataDB(); $updates += $memberDataDb->increase($userId, $memberDataFields); } if (is_array($memberInfoFields) && count($memberInfoFields)) { $memberInfoDb = $this->_getMemberInfoDB(); $updates += $memberInfoDb->increase($userId, $memberInfoFields); } return (bool) $updates; }  function updatesByIncrement($userIds, $mainFields = array(), $memberDataFields = array(), $memberInfoFields = array()) { if (!is_array($userIds) || !count($userIds)) return 0; $updates = 0; foreach ($userIds as $userId) { $updates += (int) $this->updateByIncrement($userId, $mainFields, $memberDataFields, $memberInfoFields); } return $updates; }  function updateOverflow($type) { $memberDataDb = $this->_getMemberDataDB(); return $memberDataDb->updateOverflow($type); }  function setUserStatus($userId, $type, $status = true) { list($userId, $type) = array(intval($userId), intval($type)); if ($userId <= 0 || $type <= 0) return false; $num = $this->_getUserStatusNumberWithUserStatusType($type); $membersDb = $this->_getMembersDB(); return (bool)$membersDb->setUserStatus($userId, $type, $status, $num); }  function getUserStatus($userId, $type) { list($userId, $type) = array(intval($userId), intval($type)); if ($userId <= 0 || $type <= 0) return false; if (!$user = $this->get($userId)) return false; $num = $this->_getUserStatusNumberWithUserStatusType($type); $user['userstatus'] >>= --$type; return bindec(substr(sprintf('%0'.$num.'b', $user['userstatus']), -$num)); }  function delete($userId) { $membersDb = $this->_getMembersDB(); $memberDataDb = $this->_getMemberDataDB(); $memberInfoDb = $this->_getMemberInfoDB(); $banUserDb = $this->_getBanUserDB(); $memberDataDb->delete($userId); $memberInfoDb->delete($userId); $banUserDb->deleteByUserId($userId); return (bool) $membersDb->delete($userId); }  function deletes($userIds) { if (!is_array($userIds) || !count($userIds)) return 0; $deletes = 0; foreach ($userIds as $userId) { $deletes += $this->delete($userId); } return $deletes; }  function isExist($userId) { if (!$data = $this->get($userId)) return false; return (bool)$data['uid']; }  function isExistByUserName($userName) { if (!$data = $this->getByUserName($userName)) return false; return (bool)$data['uid']; } function findOnlineUsers($onlineTimestamp) {  $onlineTimestamp = intval($onlineTimestamp); $memberDataDb = $this->_getMemberDataDB(); return $memberDataDb->getOnlineUsers($onlineTimestamp); }  function activateUser($userId, $activateCode, $siteHash,$toemail) { $userId = (int) $userId; $activateCode = trim($activateCode); if ($userId <= 0 || '' == $activateCode) return false; $membersDb = $this->_getMembersDB(); $user = $membersDb->get($userId); if($user['email'] != $toemail) return false; if (!$user) return false; $comparedActivateCode = $this->_generateUserActivateCode($user, $siteHash); if ($comparedActivateCode == $activateCode) { $this->update($userId, array('yz' => 1)); return true; } return false; }  function getUnactivatedUser($userId, $email, $siteHash) { $user = null; if ($userId) $user = $this->get($userId); if (!$user) $user = $this->getByEmail($email); if (!$user) return null; if ($user['yz'] <= 1) return null; $user['activateCode'] = $this->_generateUserActivateCode($user, $siteHash); return $user; }  function _getUserStatusNumberWithUserStatusType($type) { switch ($type) { case PW_USERSTATUS_CFGFRIEND : $num = 2; break; default: $num = 1; } return $num; } function _generateUserActivateCode($userData, $siteHash) { return md5($userData['yz'] . substr(md5($siteHash), 0, 5) . substr(md5($userData['username']), 0, 5)); } function _replaceMemberInfo($userId, $fieldsData, $checkExist = true) { if (!is_array($fieldsData) || !count($fieldsData)) return 0; $memberInfoDb = $this->_getMemberInfoDB(); if ($checkExist && $memberInfoDb->get($userId)) { return $memberInfoDb->update($fieldsData, $userId); } else { $fieldsData['uid'] = $userId; return $memberInfoDb->insert($fieldsData); } }  function getOnLineUsers() { global $winduid; $onlineUsers = GetOnlineUser(); if (!s::isArray($onlineUsers)) return array(); $userIds = array(); foreach ($onlineUsers as $key => $v) { if ($key == $winduid) continue; $userIds[] = $key; } return $userIds; }  function buildUids($fieldsData) { $uids = array(); foreach ((array)$fieldsData as $v) { $uids[] = $v['uid']; } return array_diff($uids,$winduid); }  function buildUserInfo($uids) { if (!s::isArray($uids)) return array(); require_once(R_P.'require/showimg.php'); $userInfo = array(); foreach ((array)$this->getUsersWithMemberDataByUserIds($uids) as $data) { $user['uid'] = $data['uid']; $user['username'] = $data['username']; $user['thisvisit'] = $data['thisvisit']; list($user['face']) = showfacedesign($data['icon'], '1', 's'); $userInfo[] = $user; } return $userInfo; }  function getMayKnownUserIds($fieldsData,$num = 12) { $onlineUserIds = $this->getOnLineUsers(); if (!s::isArray($onlineUserIds)) return array(); if (count($onlineUserIds) <= $num) return $onlineUserIds; $tmpApartmentUsers = $this->getUsersByApartmentAndUserIds($fieldsData['apartment'],$onlineUserIds,$num); $countApartmentUser = count($tmpApartmentUsers); $apartmentUsers = $this->buildUids($tmpApartmentUsers); if ($countApartmentUser >= $num) return $apartmentUsers; $homeUids = array_diff($onlineUserIds,$apartmentUsers); $homeNum = $num - $countApartmentUser; $tmpHomeUsers = $this->getUsersByHomeAndUserIds($fieldsData['home'],$homeUids,$homeNum); $countHomeUser = count($tmpHomeUsers); $homeUsers = $this->buildUids($tmpHomeUsers); if ($countHomeUser >= $homeNum) return array_merge($apartmentUsers,$homeUsers); $companyUids = array_diff($homeUids,$homeUsers); $companyNum = $homeNum - $countPlaceUser; $tmpCompanyUsers = $this->getUsersByCompanyidAndUserIds($fieldsData['companyid'],$companyUids,$companyNum); $countCompanyUser = count($tmpCompanyUsers); $companyUsers = $this->buildUids($tmpCompanyUsers); if ($countCompanyUser >= $companyNum) return array_merge($apartmentUsers,$homeUsers,$companyUsers); $educationUids = array_diff($companyUids,$companyUsers); $educationNum = $companyNum - $countCompanyUser; $tmpEducationUsers = $this->getUsersBySchoolidsAndUserIds($fieldsData['schoolid'],$educationUids,$educationNum); $countEducationUser = count($tmpEducationUsers); $educationUsers = $this->buildUids($tmpEducationUsers); if ($countEducationUser >= $educationNum) return array_merge($apartmentUsers,$homeUsers,$companyUsers,$educationUsers); $endUids = array_diff($educationUids,$educationUsers); $endNum = $educationNum - $countEducationUser; return array_merge($apartmentUsers,$homeUsers,$companyUsers,$educationUsers,array_slice($endUids,0,$endNum)); }  function countUsersByApartmentAndUserIds($apartment,$userIds) { $apartment = intval($apartment); if ($apartment < 1 || !s::isArray($userIds)) return 0; $membersDb = $this->_getMembersDB(); return $membersDb->countUsersByApartmentAndUserIds($apartment,$userIds); }  function getUsersByApartmentAndUserIds($apartment,$userIds,$num) { $apartment = intval($apartment); if ($apartment < 1 || !s::isArray($userIds)) return array(); $membersDb = $this->_getMembersDB(); if ($this->countUsersByApartmentAndUserIds($apartment,$userIds) < 1) return array(); return $membersDb->getUsersByApartmentAndUserIds($apartment,$userIds,$num); }  function countUsersByHomeAndUserIds($home,$userIds) { $home = intval($home); if ($home < 1 || !s::isArray($userIds)) return 0; $membersDb = $this->_getMembersDB(); return $membersDb->countUsersByHomeAndUserIds($home,$userIds); }  function getUsersByHomeAndUserIds($home,$userIds,$num) { $home = intval($home); if ($home < 1 || !s::isArray($userIds)) return array(); $membersDb = $this->_getMembersDB(); if ($this->countUsersByHomeAndUserIds($home,$userIds) < 1) return array(); return $membersDb->getUsersByHomeAndUserIds($home,$userIds,$num); }  function countUsersByCompanyidAndUserIds($companyids,$userIds) { if (!s::isArray($companyids) || !s::isArray($userIds)) return 0; $membersDb = $this->_getMembersDB(); return $membersDb->countUsersByCompanyidAndUserIds($companyids,$userIds); }  function getUsersByCompanyidAndUserIds($companyids,$userIds,$num) { if (!s::isArray($companyids) || !s::isArray($userIds)) return array(); $membersDb = $this->_getMembersDB(); if ($this->countUsersByCompanyidAndUserIds($companyids,$userIds) < 1) return array(); return $membersDb->getUsersByCompanyidAndUserIds($companyids,$userIds,$num); }  function countUsersBySchoolidsAndUserIds($schoolids,$userIds) { if (!s::isArray($schoolids) || !s::isArray($userIds)) return 0; $membersDb = $this->_getMembersDB(); return $membersDb->countUsersBySchoolidsAndUserIds($schoolids,$userIds); }  function getUsersBySchoolidsAndUserIds($schoolids,$userIds,$num) { if (!s::isArray($schoolids) || !s::isArray($userIds)) return array(); $membersDb = $this->_getMembersDB(); if ($this->countUsersBySchoolidsAndUserIds($schoolids,$userIds) < 1) return array(); return $membersDb->getUsersByCompanyidAndUserIds($schoolids,$userIds,$num); }  function getUserInfoByUserId($userId) { $userId = intval($userId); if ($userId < 1) return array(); $membersDb = $this->_getMembersDB(); return $membersDb->getUserInfoByUserId($userId); }  function getRightByGroupId($groupId){ static $groupRight; if (file_exists(D_P . "data/groupdb/group_$groupId.php")) { extract(pwCache::getData(S::escapePath(D_P . "data/groupdb/group_$groupId.php"),false)); $groupRight = $_G; } return $groupRight; } function getUserInfoWithFace($uids) { if(!S::isArray($uids)) return array(); require_once (R_P . 'require/showimg.php'); $usersInfo = array(); $users = $this->getByUserIds($uids);  foreach ($users as $key => $value) { list($value['icon']) = showfacedesign($value['icon'], 1, 's'); $usersInfo[$value['uid']] = $value; } return $usersInfo; }  function _getMembersDB() { return L::loadDB('Members', 'user'); }  function _getMemberDataDB() { return L::loadDB('MemberData', 'user'); }  function _getMemberInfoDB() { return L::loadDB('MemberInfo', 'user'); }  function _getBanUserDB() { return L::loadDB('BanUser', 'user'); } } !defined('P_W') && exit('Forbidden'); class PW_MemberdataDB extends BaseDB { var $_tableName = "pw_memberdata"; var $_primaryKey = 'uid'; function get($id) { return $this->_get($id); } function insert($fieldData) { return $this->_insert($fieldData); } function update($fieldData, $id) { return $this->_update($fieldData, $id); } function updates($fieldData, $ids) { if (!$this->_check() || !$fieldData || empty($ids)) return false;  pwQuery::update('pw_memberdata', 'uid IN (:uid)', array($ids), $fieldData); return $this->_db->affected_rows(); }  function updateOverflow($type) { $userMarkType = $this->_getUserMark(); if (!in_array($type,$userMarkType)) return false; $_sql = "SELECT uid FROM pw_memberdata WHERE $type>".intval(PW_OVERFLOW_NUM); $query = $this->_db->query($_sql); $uids = array(); while ($rt = $this->_db->fetch_array($query)) { $uids[] = $rt['uid']; } if (!$uids) return false; $this->updates(array($type=>0),$uids); return true; } function _getUserMark() { return array( 'money', 'rvrc', 'credit', 'currency', 'todaypost', 'monthpost', 'postnum', 'monoltime', 'onlinetime', 'digests', 'f_num' ); } function increase($userId, $increments) { $userId = intval($userId); if ($userId <= 0 || !is_array($increments)) return 0; $incrementStatement = array(); foreach ($increments as $field => $offset) { $offset = intval($offset); if (!$offset) continue; if ($offset<0){ $incrementStatement[] = $field . "=" . $field . $offset; }else{ $incrementStatement[] = $field . "=" . $field . "+" . $offset; } } if (empty($incrementStatement)) return 0;  $this->_db->update(pwQuery::buildClause("UPDATE :pw_table SET " . implode(", ", $incrementStatement) . " WHERE uid=:uid", array($this->_tableName, $userId))); return $this->_db->affected_rows(); } function delete($id) { return $this->_delete($id); } function getOnlineUsers($onlineTime) { $query = $this->_db->query("SELECT uid FROM " . $this->_tableName . " WHERE thisvisit >= " . $this->_addSlashes($onlineTime)); return $this->_getAllResultFromQuery($query); }  function getUsersByUserIds($userIds) { $query = $this->_db->query("SELECT * FROM " . $this->_tableName . " WHERE uid IN(" . S::sqlImplode($userIds) . ")"); return $this->_getAllResultFromQuery($query, 'uid'); } } ! defined ( 'P_W' ) && exit ( 'Forbidden' ); class GatherCache_PW_Threads_Cache extends GatherCache_Base_Cache { var $_defaultCache = PW_CACHE_MEMCACHE; var $_prefix = 'thread_';  function getThreadByThreadId($threadId) { $threadId = S::int($threadId); if ($threadId < 1) return false; if (! $this->checkMemcache()) { return $this->_getThreadNoCache($threadId); } $key = $this->_getKeyForThread($threadId); $result = $this->_cacheService->get($key); if ($result === false) { $result = $this->_getThreadNoCache($threadId); $this->_cacheService->set($key, $result); } return $result; }  function getThreadsByThreadIds($threadIds) { if (! S::isArray ( $threadIds )) { return array(); } if (!$this->checkMemcache()) { return $this->_getThreadsNoCache($threadIds); } $result = $resultInCache = $resultInDb = $keys = $_cachedThreadIds = array (); foreach ( $threadIds as $threadId ) { $keys [] = $this->_getKeyForThread ( $threadId ); } if (($threads = $this->_cacheService->get ( $keys ))) { foreach ( $threads as $value ) { $_cachedThreadIds [] = $value ['tid']; $resultInCache [$value ['tid']] = $value; } } $_noCachedThreadIds = array_diff ( $threadIds, $_cachedThreadIds ); if ($_noCachedThreadIds && ($resultInDb = $this->_getThreadsNoCache ( $_noCachedThreadIds ))) { foreach ( $resultInDb as $value ) { $this->_cacheService->set ( $this->_getKeyForThread ( $value ['tid'] ), $value ); } } $tmpResult = (array)$resultInCache + (array)$resultInDb; foreach ($threadIds as $threadId){ $result[$threadId] = isset($tmpResult[$threadId]) ? $tmpResult[$threadId] : false; } return $result; }  function getThreadAndTmsgByThreadId($threadId) { $threadId = S::int($threadId); if ($threadId < 1) return false; if (! $this->checkMemcache ()) { return $this->_getThreadAndTmsgByThreadIdNoCache($threadId); } $threadKey = $this->_getKeyForThread($threadId); $tmsgKey = $this->_getKeyForTmsg($threadId);    $thread = $this->_cacheService->get($threadKey); $tmsg = $this->_cacheService->get($tmsgKey); if ($thread === false){ $thread = $this->_getThreadNoCache($threadId); $this->_cacheService->set($threadKey, $thread); } if ($tmsg === false){ $tmsg = $this->_getTmsgNoCache($threadId); $this->_cacheService->set($tmsgKey, $tmsg); } return ($thread && $tmsg) ? array_merge($thread, $tmsg) : array(); }  function getThreadListByForumId($forumId, $offset, $limit) { if (! $this->checkMemcache ()) { return $this->_getThreadListNoCache($forumId, $offset, $limit); } $key = $this->_getKeyForThreadList($forumId, $offset, $limit); $threadListIds = $this->_cacheService->get($key); if (!$threadListIds && ($threadList = $this->_getThreadListNoCache($forumId, $offset, $limit))) { $this->_cacheService->set($key, array_keys($threadList)); } return $threadList ? $threadList : $this->getThreadsByThreadIds($threadListIds); }  function clearCacheForThreadByThreadIds($threadIds){ $threadIds = (array) $threadIds; foreach ($threadIds as $tid){ $this->_cacheService->delete($this->_getKeyForThread($tid)); } return true; }  function clearCacheForTmsgByThreadIds($threadIds){ $threadIds = (array) $threadIds; foreach ($threadIds as $tid){ $this->_cacheService->delete($this->_getKeyForTmsg($tid)); } return true; }  function clearCacheForThreadListByForumIds($forumIds){ $forumIds = (array) $forumIds; foreach ($forumIds as $forumId){ $this->_cacheService->increment($this->_getKeyForForumVersion($forumId)); } return true; }  function _getKeyForThread($threadId) { return $this->_prefix . 'tid_' . $threadId; }  function _getKeyForThreadList($forumId, $offset, $limit){ return $this->_prefix . 'fid_' . $forumId . '_offset_' . $offset . '_limit_' . $limit . '_ver_' . $this->_getForumVersionId($forumId); }  function _getKeyForTmsg($threadId){ return $this->_prefix . 'tmsg_tid_' . $threadId; }  function _getKeyForForumVersion($forumId){ return $this->_prefix . 'forumversion_' . $forumId; }  function _getForumVersionId($forumId){ $key = $this->_getKeyForForumVersion($forumId); $versionId = $this->_cacheService->get($key); if (!$versionId){ $versionId = 1; $this->_cacheService->set($key, $versionId, 3600*24); } return $versionId; }  function _getThreadNoCache($threadId) { $_dbService = L::loadDB('threads', 'forum'); return $_dbService->getThreadByThreadId ( $threadId ); }  function _getTmsgNoCache($threadIds){ $_dbService = L::loadDB('threads', 'forum'); return $_dbService->getTmsgByThreadId($threadIds); }  function _getThreadsNoCache($threadIds) { $_dbService = L::loadDB('threads', 'forum'); return $_dbService->getThreadsByThreadIds($threadIds); }  function _getThreadListNoCache($forumId, $offset, $limit){ $_dbService = L::loadDB('threads', 'forum'); return $_dbService->getThreadsByFroumId($forumId, $offset, $limit); }  function _getThreadAndTmsgByThreadIdNoCache($threadId){ $_dbService = L::loadDB('threads', 'forum'); return $_dbService->getThreadAndTmsgByThreadId($threadId); } }! defined ( 'P_W' ) && exit ( 'Forbidden' );  class GatherCache_PW_Members_Cache extends GatherCache_Base_Cache { var $_defaultCache = PW_CACHE_MEMCACHE; var $_prefix = 'member_'; var $_membersField = array ('uid' => null, 'username' => null, 'password' => null, 'safecv' => null, 'email' => null, 'groupid' => null, 'memberid' => null, 'groups' => null, 'icon' => null, 'gender' => null, 'regdate' => null, 'signature' => null, 'introduce' => null, 'oicq' => null, 'aliww' => null, 'icq' => null, 'msn' => null, 'yahoo' => null, 'site' => null, 'location' => null, 'honor' => null, 'bday' => null, 'lastaddrst' => null, 'yz' => null, 'timedf' => null, 'style' => null, 'datefm' => null, 't_num' => null, 'p_num' => null, 'attach' => null, 'hack' => null, 'newpm' => null, 'banpm' => null, 'msggroups' => null, 'medals' => null, 'userstatus' => null, 'shortcut' => null ); var $_memberDataField = array ('uid' => null, 'postnum' => null, 'digests' => null, 'rvrc' => null, 'money' => null, 'credit' => null, 'currency' => null, 'lastvisit' => null, 'thisvisit' => null, 'lastpost' => null, 'onlinetime' => null, 'monoltime' => null, 'todaypost' => null, 'monthpost' => null, 'uploadtime' => null, 'uploadnum' => null, 'follows' => null, 'fans' => null, 'newfans' => null, 'newreferto' => null, 'newcomment' => null, 'onlineip' => null, 'starttime' => null, 'postcheck' => null, 'pwdctime' => null, 'f_num' => null, 'creditpop' => null, 'jobnum' => null, 'lastmsg' => null, 'lastgrab' => null, 'punch' => null,'newnotice' => null, 'newrequest' => null ); var $_memberInfoField = array ('uid' => null, 'adsips' => null, 'credit' => null, 'deposit' => null, 'startdate' => null, 'ddeposit' => null, 'dstartdate' => null, 'regreason' => null, 'readmsg' => null, 'delmsg' => null, 'tooltime' => null, 'replyinfo' => null, 'lasttime' => null, 'digtid' => null, 'customdata' => null, 'tradeinfo' => null ); var $_singleRightField = array ('uid' => null, 'visit' => null, 'post' => null, 'reply' => null );  function getMembersByUserId($userId) { $userId = S::int ( $userId ); if ($userId < 1) { return false; } $key = $this->_getMembersKey ( $userId ); $result = $this->_cacheService->get ( $key ); if ($result === false) { $result = $this->_getMembersByUserIdNoCache ( $userId ); $result = $result ? $result : array(); $this->_cacheService->set ( $key, $result); } return $result; }  function getMemberDataByUserId($userId) { $userId = S::int ( $userId ); if ($userId < 1) { return false; } $key = $this->_getMemberDataKey ( $userId ); $result = $this->_cacheService->get ( $key ); if ($result === false) { $result = $this->_getMemberDataByUserIdNoCache ( $userId ); $result = $result ? $result : array(); $this->_cacheService->set ( $key, $result ); } return $result; }  function getMemberInfoByUserId($userId) { $userId = S::int ( $userId ); if ($userId < 1) { return false; } $key = $this->_getMemberInfoKey ( $userId ); $result = $this->_cacheService->get ( $key ); if ($result === false ) { $result = $this->_getMemberInfoByUserIdNoCache ( $userId ); $result = $result ? $result : array(); $this->_cacheService->set ( $key, $result ); } return $result; }  function getSingleRightByUserId($userId) { $userId = S::int ( $userId ); if ($userId < 1 ) { return false; } $key = $this->_getSingleRightKey ( $userId ); $result = $this->_cacheService->get ( $key ); if ($result === false){ $result = $this->_getSingleRightByUserIdNoCache ( $userId ); $result = $result ? $result : array(); $this->_cacheService->set ( $key, $result ); } return $result; }  function getMembersByUserIds($userIds) { if (! S::isArray ( $userIds )) { return false; } $userIds = array_unique ( $userIds ); $result = $_tmpResult = $keys = $_tmpUserIds = array (); foreach ( $userIds as $userId ) { $keys [$this->_getMembersKey ( $userId )] = $userId; } if (($members = $this->_cacheService->get ( array_keys($keys) ))) { $_unique = $this->getUnique(); foreach ($keys as $key=>$userId){ $_key = $_unique . $key; if (isset($members[$_key]) && is_array($members[$_key])){ $_tmpUserIds [] = $userId; $result[$userId] = $members[$_key]; } } } $userIds = array_diff ( $userIds, $_tmpUserIds ); if ($userIds) { $_tmpResult = $this->_getMembersByUserIdsNoCache ( $userIds ); foreach ($userIds as $userId){ $this->_cacheService->set ( $this->_getMembersKey ( $userId ), isset($_tmpResult[$userId]) ? $_tmpResult[$userId] : array() ); } } return (array)$result + (array)$_tmpResult; }  function getMemberDataByUserIds($userIds) { if (! S::isArray ( $userIds )) { return false; } $userIds = array_unique ( $userIds ); $result = $_tmpResult = $keys = $_tmpUserIds = array (); foreach ( $userIds as $userId ) { $keys [$this->_getMemberDataKey ( $userId )] = $userId; } if (($members = $this->_cacheService->get ( array_keys($keys) ))) { $_unique = $this->getUnique(); foreach ($keys as $key=>$userId){ $_key = $_unique . $key; if (isset($members[$_key]) && is_array($members[$_key])){ $_tmpUserIds [] = $userId; $result[$userId] = $members[$_key]; } } } $userIds = array_diff ( $userIds, $_tmpUserIds ); if ($userIds) { $_tmpResult = $this->_getMemberDataByUserIdsNoCache ( $userIds ); foreach ($userIds as $userId){ $this->_cacheService->set ( $this->_getMemberDataKey ( $userId ), isset($_tmpResult[$userId]) ? $_tmpResult[$userId] : array() ); } } return (array)$result + (array)$_tmpResult; }  function getMemberInfoByUserIds($userIds) { if (! S::isArray ( $userIds )) { return false; } $userIds = array_unique ( $userIds ); $result = $_tmpResult = $keys = $_tmpUserIds = array (); foreach ( $userIds as $userId ) { $keys [$this->_getMemberInfoKey ( $userId )] = $userId; } if (($members = $this->_cacheService->get ( array_keys($keys) ))) { $_unique = $this->getUnique(); foreach ($keys as $key=>$userId){ $_key = $_unique . $key; if (isset($members[$_key]) && is_array($members[$_key])){ $_tmpUserIds [] = $userId; $result[$userId] = $members[$_key]; } } } $userIds = array_diff ( $userIds, $_tmpUserIds ); if ($userIds) { $_tmpResult = $this->_getMemberInfoByUserIdsNoCache ( $userIds ); foreach ($userIds as $userId){ $this->_cacheService->set ( $this->_getMemberInfoKey ( $userId ), isset($_tmpResult[$userId]) ? $_tmpResult[$userId] : array() ); } } return (array)$result + (array)$_tmpResult; }  function getMemberCreditByUserIds($userIds) { if (! S::isArray ( $userIds )) { return false; } $userIds = array_unique ( $userIds ); $result = $_tmpResult = $keys = $_tmpUserIds = array (); foreach ( $userIds as $userId ) { $keys [$this->_getMemberCreditKey ( $userId )] = $userId; } if (($members = $this->_cacheService->get ( array_keys($keys) ))) { $_unique = $this->getUnique(); foreach ($keys as $key=>$userId){ $_key = $_unique . $key; if (isset($members[$_key]) && is_array($members[$_key])){ $_tmpUserIds [] = $userId; $result[$userId] = $members[$_key]; } } } $userIds = array_diff ( $userIds, $_tmpUserIds ); if ($userIds) { $_tmpResult = $this->_getMemberCreditByUserIdsNoCache ( $userIds ); foreach ($userIds as $userId){ $this->_cacheService->set ( $this->_getMemberCreditKey ( $userId ), isset($_tmpResult[$userId]) ? $_tmpResult[$userId] : array() ); } } return (array)$result + (array)$_tmpResult; }  function getCmemberAndColonyByUserIds($userIds) { if (! S::isArray ( $userIds )) { return false; } $userIds = array_unique ( $userIds ); $result = $_tmpResult = $keys = $_tmpUserIds = array (); foreach ( $userIds as $userId ) { $keys [$this->_getCmemberAndColonyKey ( $userId )] = $userId; } if (($members = $this->_cacheService->get ( array_keys($keys) ))) { $_unique = $this->getUnique(); foreach ($keys as $key=>$userId){ $_key = $_unique . $key; if (isset($members[$_key]) && is_array($members[$_key])){ $_tmpUserIds [] = $userId; $result[$userId] = $members[$_key]; } } } $userIds = array_diff ( $userIds, $_tmpUserIds ); if ($userIds) { $_tmpResult = $this->_getCmemberAndColonyByUserIdsNoCache ( $userIds ); foreach ($userIds as $userId){ $this->_cacheService->set ( $this->_getCmemberAndColonyKey ( $userId ), isset($_tmpResult[$userId]) ? $_tmpResult[$userId] : array() ); } } return (array)$result + (array)$_tmpResult; }    function getUserNameByUserId($userId) { $userId = S::int ( $userId ); if ($userId < 1) return false; $result = $this->getMembersByUserId ( $userId ); return $result ? $result['username'] : false; }  function getUserNameByUserIds($userIds) { if (! S::isArray ( $userIds )) { return false; } if (!($members = $this->getMembersByUserIds($userIds))) return false; $_userNames = array (); foreach ( $members as $member ) { $_userNames [$member ['uid']] = $member ['username']; } return $_userNames; }  function getAllFieldByUserId($userId, $isMembers = true, $isMemberData = false, $isMemberInfo = false) { $userId = S::int($userId); if ($userId < 1) return false; $members = $isMembers ? $this->getMembersByUserId($userId) : false; $memberData = $isMemberData ? $this->getMemberDataByUserId($userId) : false; $memberInfo = $isMemberInfo ? $this->getMemberInfoByUserId($userId) : false; return $this->_joinTables(array($isMembers, $isMemberData, $isMemberInfo), array($members, $memberData, $memberInfo)); }  function getAllFieldByUserIds($userIds, $isMembers = true, $isMemberData = false, $isMemberInfo = false) { if (! S::isArray ( $userIds )) return false; $arrMembers = $isMembers ? $this->getMembersByUserIds($userIds) : array(); $arrMemberData = $isMemberData ? $this->getMemberDataByUserIds($userIds) : array(); $arrMemberInfo = $isMemberInfo ? $this->getMemberInfoByUserIds($userIds) : array(); $result = array(); foreach ($userIds as $userId){ $isMembers && $members = isset ( $arrMembers [$userId]) ? $arrMembers [$userId] : false; $isMemberData && $memberData = isset ( $arrMemberData [$userId]) ? $arrMemberData [$userId] : false; $isMemberInfo && $memberInfo = isset ( $arrMemberInfo [$userId]) ? $arrMemberInfo [$userId] : false; $tmp = $this->_joinTables(array($isMembers, $isMemberData, $isMemberInfo), array($members, $memberData, $memberInfo)); $tmp && $result [$userId] = $tmp; } return $result; }  function _joinTables($tables, $values){ $tableField = array($this->_membersField, $this->_memberDataField, $this->_memberInfoField); $tableAlias = array('m.', 'md.', 'mi.'); $first = false; $result = array(); foreach ($tables as $k => $table){ if (!$first && $table){ if (!$values[$k]) return false; $first = true; } if ($first){ !$values[$k] && $values[$k] = $tableField[$k]; $values[$k][$tableAlias[$k]. 'uid'] = $values[$k]['uid']; if (isset($result['credit'])) { $values[$k]['creditinfo'] = $values[$k]['credit']; $values[$k][$tableAlias[$k]. 'credit'] = $values[$k]['credit']; } (!isset($result['credit']) && $table && $values[$k]['credit']) && $result['credit'] = $values[$k]['credit']; $result += $values[$k]; } } return $first ? $result : false; }  function clearCacheForMembersByUserIds($userIds) { $userIds = ( array ) $userIds; foreach ( $userIds as $uid ) { $this->_cacheService->delete ( $this->_getAllMembersKey ( $uid ) ); $this->_cacheService->delete ( $this->_getMembersKey ( $uid ) ); } return true; }  function clearCacheForMemberDataByUserIds($userIds) { $userIds = ( array ) $userIds; foreach ( $userIds as $uid ) { $this->_cacheService->delete ( $this->_getAllMembersKey ( $uid ) ); $this->_cacheService->delete ( $this->_getMemberDataKey ( $uid ) ); } return true; }  function clearCacheForMemberInfoByUserIds($userIds) { $userIds = ( array ) $userIds; foreach ( $userIds as $uid ) { $this->_cacheService->delete ( $this->_getAllMembersKey ( $uid ) ); $this->_cacheService->delete ( $this->_getMemberInfoKey ( $uid ) ); } return true; }  function clearCacheForSingleRightByUserIds($userIds) { $userIds = ( array ) $userIds; foreach ( $userIds as $uid ) { $this->_cacheService->delete ( $this->_getSingleRightKey ( $uid ) ); } return true; } function clearCacheForMemberCreditByUserIds($userIds) { $userIds = ( array ) $userIds; foreach ( $userIds as $uid ) { $this->_cacheService->delete ( $this->_getMemberCreditKey ( $uid ) ); } return true; } function clearCacheForCmemberAndColonyByUserIds($userIds) { $userIds = ( array ) $userIds; foreach ( $userIds as $uid ) { $this->_cacheService->delete ( $this->_getCmemberAndColonyKey ( $uid ) ); } return true; } function clearCacheForMemberTagsByUserIds($userIds) { $userIds = ( array ) $userIds; foreach ( $userIds as $uid ) { $this->_cacheService->delete ( $this->_getMemberTagsKey ( $uid ) ); } return true; }  function _getMembersByUserIdsNoCache($userIds) { if (! S::isArray ( $userIds )) return false; $membersDb = L::loadDB ( 'Members', 'user' ); return $membersDb->getUsersByUserIds ( $userIds ); }  function _getMemberDataByUserIdsNoCache($userIds) { if (! S::isArray ( $userIds )) return false; $memberDataDb = L::loadDB ( 'MemberData', 'user' ); return $memberDataDb->getUsersByUserIds ( $userIds ); }  function _getMemberInfoByUserIdsNoCache($userIds) { if (! S::isArray ( $userIds )) return false; $memberInfoDb = L::loadDB ( 'MemberInfo', 'user' ); return $memberInfoDb->getUsersByUserIds ( $userIds ); }  function _getMembersByUserIdNoCache($userId) { $userId = S::int ( $userId ); if ($userId < 1) return false; $membersDb = L::loadDB ( 'Members', 'user' ); return $membersDb->get ( $userId ); }  function _getMemberDataByUserIdNoCache($userId) { $userId = S::int ( $userId ); if ($userId < 1) return false; $memberDataDb = L::loadDB ( 'MemberData', 'user' ); return $memberDataDb->get ( $userId ); }  function _getMemberInfoByUserIdNoCache($userId) { $userId = S::int ( $userId ); if ($userId < 1) return false; $memberInfoDb = L::loadDB ( 'MemberInfo', 'user' ); return $memberInfoDb->get ( $userId ); }  function _getSingleRightByUserIdNoCache($userId) { $userId = S::int ( $userId ); if ($userId < 1) return false; $singleRightDb = L::loadDB ( 'SingleRight', 'user' ); return $singleRightDb->get ( $userId ); }  function _getMemberCreditByUserIdsNoCache($userIds) { if (!S::isArray($userIds)) return false; $memberCreditDb = L::loadDB ( 'MemberCredit', 'user' ); $memberCredits = $memberCreditDb->gets ( $userIds ); if (! S::isArray ( $memberCredits )) return false; $result = array (); foreach ( $memberCredits as $mc ) { $result [$mc ['uid']] [$mc ['cid']] = $mc ['value']; $result[$mc ['uid']]['uid'] = $mc ['uid']; } return $result; }  function _getCmemberAndColonyByUserIdsNoCache($userIds) { $cmembersDb = L::loadDB ( 'cmembers', 'colony' ); return $cmembersDb->getsCmemberAndColonyByUserIds ( $userIds ); }  function _getMembersKey($userId) { return $this->_prefix . 'main_uid_' . $userId; }  function _getMemberDataKey($userId) { return $this->_prefix . 'data_uid_' . $userId; }  function _getMemberInfoKey($userId) { return $this->_prefix . 'info_uid_' . $userId; }  function _getSingleRightKey($userId) { return $this->_prefix . 'singleright_uid_' . $userId; }  function _getMemberCreditKey($userId) { return $this->_prefix . 'credit_uid_' . $userId; }  function _getCmemberAndColonyKey($userId) { return $this->_prefix . 'colony_uid_' . $userId; }  function _getMemberTagsKey($userId) { return $this->_prefix . 'membertag_uid_' . $userId; }  function _getMembersAndMemberDataAndMemberInfoByUserIdsNoCache($userIds){ global $customfield; $fieldinfo = ''; if (is_array($customfield)) { foreach ($customfield as $value) { !$value['ifsys'] && $fieldinfo .= ',mi.field_'.(int)$value['id']; } } $membersDb = L::loadDB ( 'Members', 'user' ); return $membersDb->getMembersAndMemberDataAndMemberInfoByUserIds ( $userIds,$fieldinfo ); } function _getAllMembersKey($userId){ return $this->_prefix . 'all_uid_' . $userId; }  function getAllByUserIds($userIds, $a=false, $b=false, $c=false){ $userIds = array_unique ( (array)$userIds ); $result = $_tmpResult = $keys = $_tmpUserIds = array (); foreach ( $userIds as $userId ) { $keys [$this->_getAllMembersKey ( $userId )] = $userId; } if (($members = $this->_cacheService->get ( array_keys($keys) ))) { $_unique = $this->getUnique(); foreach ($keys as $key=>$userId){ $_key = $_unique . $key; if (isset($members[$_key]) && is_array($members[$_key])){ $_tmpUserIds [] = $userId; $result[$userId] = $members[$_key]; } } } $userIds = array_diff ( $userIds, $_tmpUserIds ); if ($userIds) { $_tmpResult = $this->_getMembersAndMemberDataAndMemberInfoByUserIdsNoCache ( $userIds ); foreach ($userIds as $userId){ $this->_cacheService->set ( $this->_getAllMembersKey ( $userId ), isset($_tmpResult[$userId]) ? $_tmpResult[$userId] : array() ); } } return (array)$result + (array)$_tmpResult; }  function getAllByUserId($userId, $a=false, $b=false, $c=false){ $userId = S::int($userId); if ($userId < 1) return false; $members = $this->getAllByUserIds($userId); return $members ? current($members) : array(); }  function getMembersAndMemberDataAndSingleRightByUserId($userId) { $userId = S::int ( $userId ); if ($userId < 1) return false; $membersAndMemberData = $this->getAllByUserId($userId); if (!$membersAndMemberData) return array(); $singleRight = $this->getSingleRightByUserId($userId); return (array)$membersAndMemberData + ($singleRight ? (array)$singleRight : $this->_singleRightField); }  function getMemberTagsByUserid($userId) { $userId = S::int ( $userId ); if ($userId < 1) { return false; } $key = $this->_getMemberTagsKey ( $userId ); $result = $this->_cacheService->get ( $key ); if ($result === false) { $memberTagsService = L::loadClass('memberTagsService', 'user'); $result = $memberTagsService->getMemberTagsByUidFromDB($userId); $result = $result ? $result : array(); $this->_cacheService->set ( $key, $result); } return $result; } }