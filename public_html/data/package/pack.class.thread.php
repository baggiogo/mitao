<?php
! defined ( 'P_W' ) && exit ( 'Forbidden' );  define ( 'PW_CACHE_VERSION', '1.0.0' ); define ( 'PW_CACHE_DIR', R_P . 'lib/utility' ); define ( 'PW_CACHE_CONFIG', 'cache_config' ); ! defined ( 'PW_CACHE_MEMCACHE' ) && define ( 'PW_CACHE_MEMCACHE', 'memcache' ); ! defined ( 'PW_CACHE_FILECACHE' ) && define ( 'PW_CACHE_FILECACHE', 'filecache' ); ! defined ( 'PW_CACHE_DBCACHE' ) && define ( 'PW_CACHE_DBCACHE', 'dbcache' ); class PW_CacheService { var $_services = array (); function PW_CacheService() { $this->__construct (); }  function __construct() { if (! isset ( $this->_services [PW_CACHE_CONFIG] ) || ! $this->_services [PW_CACHE_CONFIG]) { $this->_services [PW_CACHE_CONFIG] = new Cache_ServiceFactory (); } }  function set($key, $value, $expire = 600, $cacheName = null) { if (! ($cacheService = $this->_services [PW_CACHE_CONFIG]->getService ( $cacheName ))) { return false; } return $cacheService->set ( $key, $value, $expire ); }  function get($key, $cacheName = null) { if (! ($cacheService = $this->_services [PW_CACHE_CONFIG]->getService ( $cacheName ))) { return false; } return $cacheService->get ( $key ); }  function delete($key, $cacheName = null) { if (! ($cacheService = $this->_services [PW_CACHE_CONFIG]->getService ( $cacheName ))) { return false; } return $cacheService->delete ( $key ); } function increment($key, $value = 1, $cacheName = null) { if (! ($cacheService = $this->_services [PW_CACHE_CONFIG]->getService ( $cacheName ))) { return false; } return $cacheService->increment ( $key, $value ); }  function flush($cacheName = null) { if (! ($cacheService = $this->_services [PW_CACHE_CONFIG]->getService ( $cacheName ))) { return false; } return $cacheService->flush (); } }  class Cache_ServiceFactory { var $_defaultService = null; var $_services = array (); function Cache_ServiceFactory() { $this->__construct (); } function __construct() { $this->_defaultService = $this->build ( Cache_Config_Default::defaultCache () ); } function build($cacheName) { switch ($cacheName) { case PW_CACHE_MEMCACHE : return $this->getMemcacheService (); case PW_CACHE_FILECACHE : return $this->getFilecacheService (); case PW_CACHE_DBCACHE : return $this->getDbCacheService (); default : return false; } } function getService($cacheName) { return ($cacheName) ? $this->build ( $cacheName ) : $this->_defaultService; }  function getMemcacheService() { if (! isset ( $this->_services [PW_CACHE_MEMCACHE] ) || ! $this->_services [PW_CACHE_MEMCACHE]) { $this->_services [PW_CACHE_MEMCACHE] = new PW_MemcacheService (); } return $this->_services [PW_CACHE_MEMCACHE]; }  function getFilecacheService() { if (! isset ( $this->_services [PW_CACHE_FILECACHE] ) || ! $this->_services [PW_CACHE_FILECACHE]) { $this->_services [PW_CACHE_FILECACHE] = new PW_FilecacheService (); } return $this->_services [PW_CACHE_FILECACHE]; }  function getDbCacheService() { if (! isset ( $this->_services [PW_CACHE_DBCACHE] ) || ! $this->_services [PW_CACHE_DBCACHE]) { $this->_services [PW_CACHE_DBCACHE] = new PW_DbcacheService (); } return $this->_services [PW_CACHE_DBCACHE]; } }  class Cache_Config_Default {  function defaultCache() { return PW_CACHE_MEMCACHE; }  function getUnique() { return $GLOBALS['db_memcache']['hash']; } function getCurrentTime() { return $GLOBALS ['timestamp']; } }  class Cache_Config_Memcache {  function load() { return ($GLOBALS ['db_memcache']) ? array ($GLOBALS ['db_memcache'] ) : array (array ('host' => 'localhost', 'port' => 11211 ) ); } }  class Cache_Config_Filecache {  function getDirectory() { return D_P . 'data/gathercache/'; }  function getExt() { return '.php'; }  function createFile($key) { return Cache_Config_Filecache::getDirectory () . Cache_Config_Default::getUnique () . $key . Cache_Config_Filecache::getExt (); }  function readFile($fileName, $method = 'rb') { return readover ( $fileName, $method ); }  function writeFile($fileName, $data, $method = 'rb+', $ifLock = true, $ifCheckPath = true, $ifChmod = true) { return writeover ( $fileName, $data, $method, $ifLock, $ifCheckPath, $ifChmod ); } }  class Cache_Config_Dbcache { function connect() { $tmp = $GLOBALS ['db']->getMastdb(); return $tmp->sql; }  function getTable($key = null) { return 'pw_cache_storage'; } function createTable() {  } }  class PW_MemcacheService { var $_object = null; function PW_MemcacheService() { $this->__construct (); } function __construct() { $this->_load (); }  function set($key, $value, $expire = 600) { return (! $this->_check ()) ? false : $this->_object->set ( $this->_hash ( $key ), $value, 0, $expire ); } function increment($key, $value = 1) { return (! $this->_check ()) ? false : $this->_object->increment ( $this->_hash ( $key ), $value ); }  function get($key) { return (! $this->_check ()) ? false : $this->_object->get ( $this->_hash ( $key ) ); }  function delete($key) { return (! $this->_check ()) ? false : $this->_object->delete ( $this->_hash ( $key ) ); }  function flush() { return (! $this->_check ()) ? false : $this->_object->flush (); }  function close() { return (! $this->_check ()) ? false : $this->_object->close (); }  function _hash($key) { $unique = Cache_Config_Default::getUnique (); if (! is_array ( $key )) { return $unique . $key; } $_tmpKey = array (); foreach ( $key as $k ) { $_tmpKey [] = $unique . $k; } return $_tmpKey; }  function _check() { return (is_object ( $this->_object )) ? true : false; }  function _load() { if (! class_exists ( 'memcache' ) || ! ($configs = $this->_config ())) { return false; } $this->_object = new Memcache (); if (method_exists ( $this->_object, 'addServer' )) { foreach ( $configs as $config ) { $this->_object->addServer ( $config ['host'], $config ['port'] ); } } else { $this->_object->connect ( $configs [0] ['host'], $configs [0] ['port'] ); } }  function _config() { return Cache_Config_Memcache::load (); } }  class PW_FilecacheService { var $_object = null; function PW_FilecacheService() { $this->__construct (); } function __construct() { $this->_load (); }  function set($key, $value, $expire = 600) { return ($this->_check ()) ? $this->_object->write ( $this->_hash ( $key ), $value, $expire ) : false; }  function get($key) { return ($this->_check ()) ? $this->_object->read ( $this->_hash ( $key ) ) : false; }  function delete($key) { return ($this->_check ()) ? $this->_object->delete ( $this->_hash ( $key ) ) : false; }  function flush() { return ($this->_check ()) ? $this->_object->flush () : false; } function increment($key, $value = 1) { }  function _hash($key) { if (! is_array ( $key )) { return $key; } $_tmp = array (); foreach ( $key as $k ) { $_tmp [] = $k; } return $_tmp; }  function _load() { if (! $this->_object) { $this->_object = new Cache_File_OperateService (); } }  function _check() { return (is_object ( $this->_object )) ? true : false; } }  class Cache_File_OperateService {  function read($key, $method = 'rb') { if (! is_array ( $key )) { return $this->_read ( $key, $method ); } $_tmpData = array (); foreach ( $key as $k ) { $_tmpData [$k] = $this->_read ( $k, $method ); } return $_tmpData; } function _read($key, $method = 'rb') { if (! ($fileName = Cache_Config_Filecache::createFile ( $key ))) { return array (); } $data = unserialize ( Cache_Config_Filecache::readFile ( $fileName, $method ) ); $currentTime = Cache_Config_Default::getCurrentTime (); if (! $data || $data ['expire'] < $currentTime) { $this->delete ( $key ); return array (); } return $data ['value']; }  function write($key, $value, $expire = 600) { $fileName = Cache_Config_Filecache::createFile ( $key ); $expire = Cache_Config_Default::getCurrentTime () + $expire; return Cache_Config_Filecache::writeFile ( $fileName, serialize ( array ('expire' => $expire, 'value' => $value ) ) ); }  function delete($key) { $fileName = Cache_Config_Filecache::createFile ( $key ); if (! is_file ( $fileName )) return false; P_unlink ( $fileName ); }  function flush() { $directory = Cache_Config_Filecache::getDirectory (); if (! is_dir ( $directory )) { return false; } if (! ($dh = opendir ( $directory ))) { return false; } while ( (($file = readdir ( $dh )) !== false) ) { if (in_array ( $file, array ('.', '..' ) )) continue; $this->delete ( $directory . $file ); } closedir ( $dh ); } }  class PW_DbcacheService { var $_object = null; function PW_DbcacheService() { $this->__construct (); } function __construct() { $this->_load (); }  function set($key, $value, $expire = 600) { return ($this->_check ()) ? $this->_object->insert ( $this->_hash ( $key ), $value, $expire ) : false; }  function get($key) { return ($this->_check ()) ? $this->_object->get ( $this->_hash ( $key ) ) : false; }  function delete($key) { return ($this->_check ()) ? $this->_object->delete ( $this->_hash ( $key ) ) : false; }  function flush() { return ($this->_check ()) ? $this->_object->flush () : false; } function increment($key, $value = 1) { }  function _hash($key) { $unique = Cache_Config_Default::getUnique (); if (! is_array ( $key )) { return $unique . $key; } $_tmp = array (); foreach ( $key as $k ) { $_tmp [] = $unique . $k; } return $_tmp; }  function _load() { if (! $this->_object) { $this->_object = new Cache_Db_OperateService (); } }  function _check() { return (is_object ( $this->_object )) ? true : false; } }  class Cache_Db_OperateService { var $_conn = NULL; function Cache_Db_OperateService() { $this->__construct (); } function __construct() { $this->_conn = $this->connect (); }  function insert($key, $value, $expire = 600) { $expire = Cache_Config_Default::getCurrentTime () + $expire; return $this->query ( "REPLACE INTO " . $this->getTableName ( $key ) . " (ckey,cvalue,expire) VALUES (" . $this->escape ( $key ) . "," . $this->escape ( serialize ( $value ) ) . "," . $this->escape ( $expire ) . ")" ); }  function get($key) { $key = (is_array ( $key )) ? $key : array ($key ); $currentTime = Cache_Config_Default::getCurrentTime (); $query = $this->query ( "SELECT ckey,cvalue FROM " . $this->getTableName ( $key ) . " WHERE ckey IN ( " . $this->escape ( $key ) . ") AND expire >= " . $this->escape ( $currentTime ) ); $result = $this->fetchArray ( $query ); return $result; }  function delete($key) { $key = (is_array ( $key )) ? $key : array ($key ); return $this->query ( "DELETE FROM " . $this->getTableName ( $key ) . " WHERE ckey IN( " . $this->escape ( $key ) . ")" ); }  function flush() { return $this->query ( "TRUNCATE TABLE " . $this->getTableName () ); }  function query($sql) { return mysql_query ( $sql, $this->_conn ); }  function escape($key) { if (! is_array ( $key )) { return "'" . $key . "'"; } $_tmp = ''; foreach ( $key as $k ) { $_tmp .= (($_tmp) ? ',' : '') . "'" . $k . "'"; } return $_tmp; }  function fetchArray($result, $type = MYSQL_ASSOC) { $rt = array (); while ( $row = mysql_fetch_array ( $result, $type ) ) { $rt [$row ['ckey']] = unserialize ( $row ['cvalue'] ); } return $rt; }  function getTableName($key = null) { return Cache_Config_Dbcache::getTable ( $key ); }  function connect() { return Cache_Config_Dbcache::connect (); } } !defined('P_W') && exit('Forbidden'); define('PW_NAV_TYPE_MAIN', 'main'); define('PW_NAV_TYPE_HEAD_LEFT', 'head_left'); define('PW_NAV_TYPE_HEAD_RIGHT', 'head_right'); define('PW_NAV_TYPE_FOOT', 'foot');  class PW_NavConfig { function add($navType, $fieldsData) { if (!$this->_checkNavType($navType)) return 0; $navConfigDb = $this->_getNavConfigDB(); $fieldsData['type'] = $navType; isset($fieldsData['style']) && $fieldsData['style'] = $this->_encodeStyleField($fieldsData['style']); isset($fieldsData['pos']) && $fieldsData['pos'] = $this->_encodePosField($fieldsData['pos']); return $navConfigDb->add($fieldsData); } function get($navId) { $navConfigDb = $this->_getNavConfigDB(); $data = $navConfigDb->get($navId); if (!$data) return null; $data['style'] = $this->_decodeStyleField($data['style']); $data['pos'] = $this->_decodePosField($data['pos']); return $data; } function getByKey($navKey, $navType = '') { $navKey = trim($navKey); if ('' == $navKey) return null; $navConfigDb = $this->_getNavConfigDB(); return $navConfigDb->getByKey($navKey, $navType); } function update($navId, $fieldsData) { if ($navId <= 0) return 0; $navConfigDb = $this->_getNavConfigDB(); isset($fieldsData['style']) && $fieldsData['style'] = $this->_encodeStyleField($fieldsData['style']); isset($fieldsData['pos']) && $fieldsData['pos'] = $this->_encodePosField($fieldsData['pos']); return $navConfigDb->update($navId, $fieldsData); } function controlShowByKey($navKey, $isShow = false) { $navKey = trim($navKey); if ('' == $navKey) return 0; $navConfigDb = $this->_getNavConfigDB(); return $navConfigDb->updateByKey($navKey, array('isshow'=>$isShow ? 1 : 0)); } function delete($navId) { if ($navId <= 0) return 0; $navIds = array($navId); $navConfigDb = $this->_getNavConfigDB(); $data = $navConfigDb->get($navId); if (!$data) return 0; foreach ($navConfigDb->findSubNavsByType($data['type'], $navId) as $nav) { $navIds[] = $nav['nid']; } return $navConfigDb->deletes($navIds); } function deleteByType($navType) { if (!$this->_checkNavType($navType)) return array(); $navConfigDb = $this->_getNavConfigDB(); return $navConfigDb->deleteByType($navType); } function deleteByKey($navKey) { $navKey = trim($navKey); if ('' == $navKey) return 0; $navConfigDb = $this->_getNavConfigDB(); $exist = $navConfigDb->getByKey($navKey); if (!$exist) return 0; return $this->delete($exist['nid']); } function findNavListByType($navType) { if (!$this->_checkNavType($navType)) return array(); $navConfigDb = $this->_getNavConfigDB(); return $navConfigDb->findByType($navType); } function relateNavList($navList) { $relativeNavs = array(); foreach ($navList as $nav) { $nav['pos'] = $this->_decodePosField($nav['pos']); if ($nav['upid']) { $relativeNavs[$nav['upid']]['subs'][$nav['nid']] = $nav; } else { $relativeNavs[$nav['nid']]['data'] = $nav; } } return $relativeNavs; } function findSubNavListByType($navType, $parentNavId = 0) { if (!$this->_checkNavType($navType)) return array(); $navConfigDb = $this->_getNavConfigDB(); return $navConfigDb->findSubNavsByType($navType, $parentNavId); } function findNavConfigs(){ static $navConfigData = array(); if(!$navConfigData){  extract(pwCache::getData(D_P . 'data/bbscache/navcache.php',false));  } if(!$navConfigData){ $navConfigDb = $this->_getNavConfigDB(); $navConfigData = $navConfigDb->findNavConfigs(); } return $navConfigData; } function findValidNavListByTypeAndPostion($navType, $postion, $currentPostion = array()) { $relativeNavs = array(); $notValidParent = array(); $currentPostionsKeeper = array(); $navConfigData = $this->findNavConfigs(); foreach ((array)$navConfigData[$navType] as $nav) { if (!$nav['isshow']) continue; $nav['iscurrent'] = false; $nav['pos'] = $this->_decodePosField($nav['pos']); $nav['style'] = $this->_decodeStyleField($nav['style']); if ($nav['upid']) { $relativeNavs[$nav['upid']]['subs'][$nav['nid']] = $nav; continue; } if ($this->_isInPos($postion, $nav['pos'])) { $currentPostionsKeeper[$nav['nid']] = $this->_compareIsCurrent($currentPostion, $nav['nkey']); $relativeNavs[$nav['nid']]['data'] = $nav; } else { $notValidParent[$nav['nid']] = $nav['nid']; } } $maxCurrentStatus = !empty($currentPostionsKeeper) ? max($currentPostionsKeeper) : 0; if ($maxCurrentStatus) { $relativeNavs[array_search($maxCurrentStatus, $currentPostionsKeeper)]['data']['iscurrent'] = true; } foreach ($notValidParent as $navId) { unset($relativeNavs[$navId]); } return $relativeNavs; }  function _compareIsCurrent($currentPostion, $navKey) { if (!is_array($currentPostion) || !count($currentPostion) || '' == $navKey) return 0; if ($currentPostion['mode'] == $navKey) return 1; if (implode("_", $currentPostion) == $navKey) return 2; return 0; }  function _getNavConfigDB() { return L::loadDB('navconfig', 'site'); } function _checkNavType($navType) { return in_array($navType, array(PW_NAV_TYPE_MAIN, PW_NAV_TYPE_HEAD_LEFT, PW_NAV_TYPE_HEAD_RIGHT, PW_NAV_TYPE_FOOT)); } function _encodePosField($posValue) { if ('-1' == $posValue) return $posValue; if (is_array($posValue)) return implode(',', $posValue); return ''; } function _decodePosField($posField) { if ('-1' == $posField) return $posField; if ($posField) return explode(',', $posField); return array(); } function _isInPos($postion, $posValue) { if ('-1' == $posValue) return true; if (is_array($posValue)) return in_array($postion, $posValue); return false; } function _encodeStyleField($styleData) { return implode("|", array($styleData['color'], $styleData['b'], $styleData['i'], $styleData['u'])); } function _decodeStyleField($styleField) { $styleField = explode('|', $styleField); return array('color'=>$styleField[0], 'b'=>$styleField[1], 'i'=>$styleField[2], 'u'=>$styleField[3]); }  function userHomeNavigation($type,$model) { if (!$type || !$model) return array(); $homenavigations = $this->findValidNavListByTypeAndPostion($type, $model); if (!S::isArray($homenavigations)) return array(); $homenavigation = array(); $homenavigation['linkup'][] = array_shift($homenavigations); $homenavigation['linkup'][] = array_shift($homenavigations); $homenavigation['linkup'][] = array_shift($homenavigations); foreach ($homenavigations as $value) { $homenavigation['linkdown'][] = $value; } return $homenavigation; } } ! defined ( 'P_W' ) && exit ( 'Forbidden' );  define ( 'PW_UPDATE', 'update' ); define ( 'PW_SELECT', 'select' ); define ( 'PW_DELETE', 'delete' ); define ( 'PW_INSERT', 'insert' ); define ( 'PW_REPLACE', 'replace' ); class PW_Gather {  function spreadCache($cacheName) { if (! $cacheName) return false; return $this->_loadGatherCache ( $cacheName ); }  function spreadQuery($operate, $tableNames, $fields, $expand = array()) { if (! S::isArray ( $tableNames )) { return false; } foreach ( $tableNames as $tableName ) { $this->_loadGatherQuery ( $operate, $tableName, $fields, $expand ); } return true; }  function spreadInfo($gatherName, $information = null, $defaultName = 'general') { if (! $gatherName) return false; return $this->_loadGatherInfo ( $gatherName, $information ); } function _loadGatherCache($cacheName) { static $_cacheNames = null; $cacheName = strtolower ( $cacheName ); if (! isset ( $_cacheNames [$cacheName] )) { $filePath = R_P . "lib/gather/gathercache/" . $cacheName . ".cache.php"; if (! is_file ( $filePath )) return false;  $className = 'GatherCache_' . $cacheName . '_Cache'; $filePath = pwPack::classPath ( $filePath, $className );  require_once S::escapePath ( $filePath );  if (! class_exists ( $className )) { return false; } $_cacheNames [$cacheName] = &new $className (); } return $_cacheNames [$cacheName]; } function _loadGatherQuery($operate, $tableName, $fields, $expand) { static $_classes = null; $tmpTableName = $tableName = strtolower ( $tableName ); $tableName = $this->_convertTableName ( $tableName ); if (! isset ( $_classes [$tableName] )) { $filePath = R_P . "lib/gather/gatherquery/" . $tableName . ".query.php"; if (! is_file ( $filePath )) return false; require_once S::escapePath ( $filePath ); $className = 'GatherQuery_UserDefine_' . $tableName; if (! class_exists ( $className )) { return false; } $_classes [$tableName] = &new $className (); } return $this->dispatchQuery ( $_classes [$tableName], $operate, $tmpTableName, $fields, $expand ); } function dispatchQuery($userDefineClass, $operate, $tableName, $fields, $expand = array()) { if (! S::isObj ( $userDefineClass ) || ! $operate || ! S::isArray ( $fields )) { return false; } $userDefineClass->init (); switch (strtolower ( $operate )) { case 'insert' : $userDefineClass->insert ( $tableName, $fields, $expand ); break; case 'replace' : $userDefineClass->insert ( $tableName, $fields, $expand ); break; case 'select' : $userDefineClass->select ( $tableName, $fields, $expand ); break; case 'update' : $userDefineClass->update ( $tableName, $fields, $expand ); break; case 'delete' : $userDefineClass->delete ( $tableName, $fields, $expand ); break; default : break; } return true; } function _loadGatherInfo($gatherName, $information, $defaultName = 'general') { $filePath = R_P . "lib/gather/gatherinfo/" . $defaultName . ".service.php"; if (! is_file ( $filePath )) return false; require_once S::escapePath ( $filePath ); $className = 'GatherInfo_' . $defaultName . '_Service'; if (! class_exists ( $className ) || ! is_callable ( array ($className, $gatherName ) )) { return false; } $object = &new $className (); return $object->$gatherName ( $information ); } function _convertTableName($tablename) { $extendTableNames = array (); if ($GLOBALS ['db_tlist']) { foreach ( $GLOBALS ['db_tlist'] as $k => $v ) { $extendTableNames ['pw_tmsgs' . ($k ? $k : '')] = 'pw_threads'; } } if ($GLOBALS ['db_plist']) { foreach ( $GLOBALS ['db_plist'] as $k => $v ) { $extendTableNames ['pw_posts' . ($k ? $k : '')] = 'pw_posts'; } } $tableNames = array ('pw_tmsgs' => 'pw_threads', 'pw_memberinfo' => 'pw_members', 'pw_memberdata' => 'pw_members', 'pw_singleright' => 'pw_members', 'pw_membercredit' => 'pw_members', 'pw_banuser' => 'pw_members', 'pw_cmembers' => 'pw_members', 'pw_membertags_relations' => 'pw_members', 'pw_forumdata' => 'pw_forums', 'pw_announce' => 'pw_forums'); $tableNames += $extendTableNames; return (isset ( $tableNames [$tablename] )) ? $tableNames [$tablename] : $tablename; } } class GatherCache_Base_Cache { var $_cacheService = null; function GatherCache_Base_Cache() { $this->__construct (); } function __construct() { $this->_cacheService = ($this->_cacheService) ? $this->_cacheService : $this->getCacheService (); } function checkMemcache() { static $isMemcache = null; if (! isset ( $isMemcache )) { $isMemcache = class_exists ( "Memcache" ) && strtolower ( $GLOBALS ['db_datastore'] ) == 'memcache'; } return $isMemcache; } function getUnique() { return $GLOBALS ['db_memcache'] ['hash']; } function getCacheService() { return L::loadClass ( 'cacheservice', 'utility' ); } }!defined('P_W') && exit('Forbidden'); class PW_ThreadsDB extends BaseDB { var $_tableName = 'pw_threads'; var $_tableName2 = 'pw_tmsgs'; var $_tableName3 = 'pw_threads_img'; var $_primaryKey = 'tid'; function insert($fieldData){ return $this->_insert($fieldData); } function update($fieldData,$id){ return $this->_update($fieldData,$id); } function delete($id){ return $this->_delete($id); } function get($id){ return $this->_get($id); } function count(){ return $this->_count(); }  function getsBythreadIds($threadIds){ $threadIds = (is_array($threadIds)) ? $threadIds : explode(",",$threadIds); foreach($threadIds as $threadId){ $table = GetTtable($threadId); $tables[$table][] = $threadId; } $threads = array(); foreach($tables as $table=>$tids){ $t = $this->_getsBythreadIds($tids,$table); $threads = array_merge($threads,$t); } $tmp = array(); foreach($threads as $t){ $tmp[$t['tid']] = $t; } $result = array(); foreach($threadIds as $threadId){ (isset($tmp[$threadId])) ? $result[] = $tmp[$threadId] : ''; } return $result; } function _getsBythreadIds($threadIds,$tmsgsTableName){ $this->_tableName2 = ($tmsgsTableName) ? $tmsgsTableName : $this->_tableName2; $threadIds = (is_array($threadIds)) ? S::sqlImplode($threadIds) : $threadIds; $query = $this->_db->query ( "SELECT t.*,th.content FROM ".$this->_tableName." t left join ".$this->_tableName2." th on t.tid=th.tid WHERE t.ifcheck = 1 AND t.fid != 0  AND t.tid in(".$threadIds.") ORDER BY t.postdate DESC" ); return $this->_getAllResultFromQuery ( $query ); } function _getFilterids(){ global $db_filterids; $_sql_where=''; if($db_filterids){ $_sql_where=" AND t.fid not in(".$db_filterids.") "; } return $_sql_where; } function getLatestThreadsCount($forumIds, $starttime, $endtime){ $_sql_where=$this->_getFilterids(); if ($forumIds) { $forumIds = (is_array ( $forumIds )) ? $forumIds : array ($forumIds ); $_sql_where .= " AND t.fid IN(" . S::sqlImplode ( $forumIds ) . ")"; } if ($starttime) { $ifpostdate = 1; $_sql_where .= " AND t.postdate > " . S::sqlEscape ( $starttime ); } if ($endtime) { $ifpostdate = 1; $_sql_where .= " AND t.postdate < " . S::sqlEscape ( $endtime ); } if ($ifpostdate == 1) { $forceIndex = 'FORCE INDEX (idx_postdate)'; } $total=$this->countSearch("SELECT count(*) as total FROM ".$this->_tableName." t ".$forceIndex." WHERE t.ifcheck = 1 AND t.fid !=0 ".$_sql_where); return ($total<500) ? $total :500; } function getLatestThreads($forumIds, $starttime, $endtime, $offset, $limit){ $threadIds = $this->_getLatestThreads($forumIds, $starttime, $endtime, $offset,$limit); if(!$threadIds) return false; $tmp = array(); foreach($threadIds as $t){ $tmp[] = $t['tid']; } return $this->getsBythreadIds($tmp); } function _getLatestThreads($forumIds, $starttime, $endtime, $offset, $limit){ $_sql_where=$this->_getFilterids(); if ($forumIds) { $forumIds = (is_array ( $forumIds )) ? $forumIds : array ($forumIds ); $_sql_where .= " AND t.fid IN(" . S::sqlImplode ( $forumIds ) . ")"; } if ($starttime) { $_sql_where .= " AND t.postdate > " . S::sqlEscape ( $starttime ); } if ($endtime) { $_sql_where .= " AND t.postdate < " . S::sqlEscape ( $endtime ); } $query = $this->_db->query ("SELECT t.tid FROM ".$this->_tableName." t WHERE t.ifcheck = 1 AND t.ifshield != 1 ".$_sql_where." ORDER BY t.postdate DESC LIMIT " . $offset . "," . $limit ); return $this->_getAllResultFromQuery ( $query ); }  function getLatestImageThreads($limit){ $limit = intval($limit); if (!$limit) return array(); $query = $this->_db->query ("SELECT t.tid,t.subject FROM ".$this->_tableName3." ti LEFT JOIN ".$this->_tableName." t USING(tid) WHERE t.ifcheck = 1 AND t.fid != 0 AND t.locked = 0 ORDER BY t.postdate DESC LIMIT ". $limit ); return $this->_getAllResultFromQuery ( $query ,'tid'); } function deleteTucoolThreadsByTids($tids){ return pwQuery::delete($this->_tableName3, 'tid IN (:tid)', array($tids)); } function getDigestThreadsCount($uid, $forumIds, $starttime, $endtime){ $_sql_where=$this->_getFilterids(); if ($uid) { $_sql_where .= ' AND t.authorid=' . S::sqlEscape($uid); } if ($forumIds) { $forumIds = (is_array ( $forumIds )) ? $forumIds : array ($forumIds ); $_sql_where .= " AND t.fid IN(" . S::sqlImplode ( $forumIds ) . ")"; } if ($starttime) { $_sql_where .= " AND t.postdate > " . S::sqlEscape ( $starttime ); } if ($endtime) { $_sql_where .= " AND t.postdate < " . S::sqlEscape ( $endtime ); } $total=$this->countSearch("SELECT count(*) as total FROM ".$this->_tableName." t WHERE t.ifcheck = 1{$_sql_where} AND t.digest IN ('1','2')"); return ($total<500) ? $total : 500; } function getDigestThreads($uid, $digest,$forumIds, $starttime, $endtime, $offset, $limit){ $threadIds = $this->_getDigestThreads($uid,$digest,$forumIds,$starttime,$endtime,$offset,$limit); if(!$threadIds) return false; $tmp = array(); foreach($threadIds as $t){ $tmp[] = $t['tid']; } return $this->getsBythreadIds($tmp); } function _getDigestThreads($uid, $digest, $forumIds, $starttime, $endtime, $offset, $limit){ $_sql_where=$this->_getFilterids(); if ($uid) { $_sql_where .= ' AND t.authorid=' . S::sqlEscape($uid); } if ($digest) { $digest = (is_array ( $digest )) ? $digest : array ($digest ); $_sql_where .= " AND t.digest IN(" . S::sqlImplode ( $digest ) . ")"; } if ($forumIds) { $forumIds = (is_array ( $forumIds )) ? $forumIds : array ($forumIds ); $_sql_where .= " AND t.fid IN(" . S::sqlImplode ( $forumIds ) . ")"; } if ($starttime) { $_sql_where .= " AND t.postdate > " . S::sqlEscape ( $starttime ); } if ($endtime) { $_sql_where .= " AND t.postdate < " . S::sqlEscape ( $endtime ); } $query = $this->_db->query ( "SELECT t.tid FROM ".$this->_tableName." t WHERE t.ifcheck = 1{$_sql_where} ORDER BY t.postdate DESC LIMIT " . $offset . "," . $limit ); return $this->_getAllResultFromQuery ( $query ); } function getThreadsCountByPostdate($postdate) { $_sql_where=$this->_getFilterids(); $total=$this->countSearch("SELECT count(*) as total FROM ".$this->_tableName." t WHERE t.ifcheck = 1 ".$_sql_where." AND postdate>=".S::sqlEscape($postdate)); return $total; } function getThreadsByPostdate($offset,$limit,$postdate) { $threadIds = $this->_getThreadsByPostdate($offset,$limit,$postdate); if(!$threadIds) return false; $tmp = array(); foreach($threadIds as $t){ $tmp[] = $t['tid']; } return $this->getsBythreadIds($tmp); } function _getThreadsByPostdate($offset,$limit,$postdate){ $_sql_where=$this->_getFilterids(); $query = $this->_db->query ("SELECT t.tid FROM ".$this->_tableName." t WHERE t.ifcheck = 1 ".$_sql_where." AND t.postdate>=".S::sqlEscape($postdate)." ORDER BY t.postdate DESC LIMIT " . $offset . "," . $limit ); return $this->_getAllResultFromQuery ( $query ); }  function countSearch($sql){ $result = $this->_db->get_one ( $sql ); return ($result) ? $result['total'] : 0; }  function getSearch($sql){ $query = $this->_db->query ($sql); return $this->_getAllResultFromQuery ( $query ); }  function getThreadsByFroumId($forumId, $offset, $limit) { $forumId = S::int($forumId); if($forumId < 1){ return false; } $query = $this->_db->query("SELECT * FROM " . $this->_tableName . " WHERE fid=" . S::sqlEscape($forumId) . "AND ifcheck=1 AND specialsort=0 ORDER BY lastpost DESC LIMIT $offset,$limit"); return $this->_getAllResultFromQuery($query, $this->_primaryKey); }  function getThreadsByThreadIds($threadIds) { if (!S::isArray($threadIds)) { return false; } $query = $this->_db->query("SELECT * FROM " . $this->_tableName . " WHERE tid IN (" . S::sqlImplode($threadIds, false) . ") ORDER BY lastpost DESC"); return $this->_getAllResultFromQuery($query, $this->_primaryKey); }  function getTmsgByThreadId($threadId) { $threadId = S::int($threadId); if($threadId < 1){ return false; } $pw_tmsgs = GetTtable($threadId); return $this->_db->get_one("SELECT * FROM $pw_tmsgs WHERE tid=" . S::sqlEscape($threadId)); }  function getThreadByThreadId($threadId) { $threadId = S::int($threadId); if($threadId < 1){ return false; } return $this->_db->get_one("SELECT * FROM ". $this->_tableName ." WHERE tid=" . S::sqlEscape($threadId)); }  function getThreadAndTmsgByThreadId($threadId) { $threadId = S::int($threadId); if($threadId < 1){ return false; } $pw_tmsgs = GetTtable($threadId); return $this->_db->get_one("SELECT t.* ,tm.* FROM {$this->_tableName} t LEFT JOIN $pw_tmsgs tm ON t.tid=tm.tid WHERE t.tid=" . S::sqlEscape($threadId)); }  function deleteByThreadId($threadId) { $threadId = S::int($threadId); if($threadId < 1){ return false; }  pwQuery::delete($this->_tableName, 'tid=:tid', array($threadId)); return $this->_db->affected_rows(); }  function deleteByThreadIds($threadIds) { if(!S::isArray($threadIds)){ return false; }  pwQuery::delete($this->_tableName, 'tid IN (:tid)', array($threadIds)); return $this->_db->affected_rows(); }  function deleteByForumId($forumId) { $forumId = S::int($forumId); if($forumId < 1){ return false; }  pwQuery::delete($this->_tableName, 'fid=:fid', array($forumId)); return $this->_db->affected_rows(); }  function deleteByAuthorId($authorId) { $authorId = S::int($authorId); if($authorId < 1){ return false; }  pwQuery::delete($this->_tableName, 'authorid=:authorid', array($authorId)); return $this->_db->affected_rows(); } function setTpcStatusByThreadIds($tids,$mask){ $this->_db->update("UPDATE $this->_tableName SET tpcstatus=tpcstatus & ".S::int($mask)." WHERE tid IN(".S::sqlImplode($tids).")"); } }! function_exists ( 'readover' ) && exit ( 'Forbidden' );  class PW_AutoJob { var $_db = null; var $_hour = 3600; var $_timestamp = null; var $_cache = true; function PW_AutoJob() { global $db, $timestamp; $this->_db = & $db; $this->_timestamp = $timestamp; } function run($userid, $groupid) { return $this->jobAutoController ( $userid, $groupid ); } function jobAutoController($userid, $groupid) { $userid = intval ( $userid ); $groupid = intval ( $groupid ); if ($groupid < 1 || $userid < 1) { return; } if (! $jobLists = $this->_jobAutoFilterHandler ( $userid, $groupid )) { return; } $current = $this->_timestamp; foreach ( $jobLists as $job ) { $this->_jobAutoCreateHandler ( $userid, $job, $current ); } } function _jobAutoFilterHandler($userid, $groupid) { $jobs = $this->getJobsAuto (); if (! $jobs) { return false; } $current = $this->_timestamp; $jobLists = $jobIds = $periods = $preposes = array (); foreach ( $jobs as $job ) { if ($job ['isopen'] == 0) { continue; } if ((isset ( $job ['endtime'] ) && $job ['endtime'] != 0 && $job ['endtime'] < $current)) { continue; } if ((isset ( $job ['starttime'] ) && $job ['starttime'] != 0 && $job ['starttime'] > $current)) { continue; } if (isset ( $job ['usergroup'] ) && $job ['usergroup'] != '') { $usergroups = explode ( ",", $job ['usergroup'] ); if (! in_array ( $groupid, $usergroups )) { continue; } } if (isset ( $job ['period'] ) && $job ['period'] > 0) { $periods [] = $job ['id']; } if (isset ( $job ['prepose'] ) && $job ['prepose'] > 0) { $preposes [$job ['prepose']] = $job ['id']; } if (isset ( $job ['number'] ) && $job ['number'] != 0) { $number = $this->countJoberByJobId ( $job ['id'] ); if ($number >= $job ['number']) { continue; } }  if (S::inArray($job['job'],array('doAuthAlipay','doAuthMobile'))) { if (!$GLOBALS['db_authstate']) return false; $userService = L::loadClass('UserService','user'); if ($job['job'] == 'doAuthAlipay' && $userService->getUserStatus($userid, PW_USERSTATUS_AUTHALIPAY)){ return false; } if ($job['job'] == 'doAuthMobile' && $userService->getUserStatus($userid, PW_USERSTATUS_AUTHMOBILE)){ return false; } } $jobLists [$job ['id']] = $job; $jobIds [] = $job ['id']; } if (! $jobLists) { return false; } $joins = $this->getJobersByJobIds ( $userid, $jobIds ); if ($joins) { foreach ( $joins as $join ) { $t_job = array (); $t_job = $jobLists [$join ['jobid']]; if (in_array ( $join ['jobid'], $periods )) { if ($join ['status'] >= 3 && $join ['total'] > 0) { if ($join ['next'] < $current) { $this->_jobAutoAgainHandler ( $userid, $t_job, $current ); } } } unset ( $t_job ); unset ( $jobLists [$join ['jobid']] ); } } if (! $jobLists) { return false; } if ($preposes) { $joins = $this->getJobersByJobIds ( $userid, array_keys ( $preposes ) ); if ($joins) { foreach ( $joins as $join ) { if ($join ['total'] > 0) { unset ( $preposes [$join ['jobid']] ); } } } if ($preposes) { foreach ( $preposes as $jobid ) { unset ( $jobLists [$jobid] ); } } } return $jobLists; } function _jobAutoAgainHandler($userid, $job, $current) { $next = $current; if (isset ( $job ['period'] ) && $job ['period'] != 0) { $next = $current + $job ['period'] * $this->_hour; } $job ['next'] = $next ? $next : $current; $this->_againJober ( $userid, $job ['id'], $job ['next'], $current ); } function _againJober($userId, $jobId, $next, $current, $jober = array()) { $jober = $jober ? $jober : $this->getJoberByJobId ( $userId, $jobId ); if (! $jober) { return array (); } $data = array (); $data ['current'] = 1; $data ['step'] = 0; $data ['last'] = $current; $data ['next'] = $next; $data ['status'] = 0; $result = $this->updateJober ( $data, $jober ['id'] ); if ($result) { $this->increaseJobNum ( $userId ); } return $result; } function updateJober($fields, $id) { $joberDao = $this->_getJoberDao (); return $joberDao->update ( $fields, $id ); } function getJobsAuto() { if ($this->_cache) { $jobs = $this->getFileCache (); if ($jobs) { $autos = array (); foreach ( $jobs as $job ) { if ($job ['auto'] == 1) { $autos [] = $job; } } return $autos; } } $jobDao = $this->_getJobDao (); return $jobDao->getByAuto (); } function getFileCache() { if (! $this->_cache) { return array (); }  extract(pwCache::getData(S::escapePath ( $this->getCacheFileName ()), false)); $jobLists = ($jobLists) ? $jobLists : $GLOBALS ['jobLists']; if ($jobLists) { return $jobLists; } return $this->setFileCache (); } function setFileCache() { $jobDao = $this->_getJobDao (); $jobs = $jobDao->getAll (); $jobLists = "\$jobLists=" . pw_var_export ( $jobs ) . ";"; pwCache::setData ( $this->getCacheFileName (), "<?php\r\n" . $jobLists . "\r\n?>" ); return $jobs; } function _jobAutoCreateHandler($userid, $job, $current) { if (isset ( $job ['period'] ) && $job ['period'] != 0) { $next = $current + $job ['period'] * $this->_hour; $job ['next'] = $next ? $next : $current; } $this->_createJober ( $userid, $job ['id'], $job ['next'], $current ); } function _createJober($userId, $jobId, $next, $current, $jober = array()) { $jober = $jober ? $jober : $this->getJoberByJobId ( $userId, $jobId ); if ($jober) { return array (); } $data = array (); $data ['jobid'] = $jobId; $data ['userid'] = $userId; $data ['current'] = 1; $data ['step'] = 0; $data ['last'] = $current; $data ['next'] = $next; $data ['status'] = 0; $data ['creattime'] = $current; return $this->addJober ( $data ); } function getCacheFileName() { return R_P . "data/bbscache/jobs.php"; } function getJobersByJobIds($userid, $ids) { $joberDao = $this->_getJoberDao (); return $joberDao->getJobersByJobIds ( $userid, $ids ); } function addJober($fields) { $fields ['userid'] = intval ( $fields ['userid'] ); $fields ['jobid'] = intval ( $fields ['jobid'] ); if ($fields ['userid'] < 1 || $fields ['jobid'] < 1) { return null; } $joberDao = $this->_getJoberDao (); $result = $joberDao->add ( $fields ); if ($result) { $this->increaseJobNum ( $fields ['userid'] ); } return $result; } function increaseJobNum($userid) { $this->updateJobNum ( $userid ); } function updateJobNum($userid) { $jobnum = $this->countJobnum ( $userid ); ($jobnum > 0) ? $jobnum : 0; $userService = L::loadClass ( 'UserService', 'user' ); return $userService->update ( $userid, array (), array ('jobnum' => $jobnum ) ); } function countJobNum($userId) { if (! $userId) return false; $joblists = $this->getAppliedJobs ( $userId ); $joblists = $joblists ? $joblists : array (); $num = 0; foreach ( $joblists as $job ) { if ($job ['isopen'] == 0 || $job['isuserguide']) continue; $num ++; } return $num; } function getAppliedJobs($userid) { $joberDao = $this->_getJoberDao (); $jobers = $joberDao->getAppliedJobs ( $userid ); if (! $jobers) { return array (); } return $this->buildJobListByIds ( $jobers ); } function buildJobListByIds($jobers) { if (! $jobers) { return array (); } $jobIds = $tmp = array (); foreach ( $jobers as $job ) { $jobIds [] = $job ['jobid']; $tmp [$job ['jobid']] = $job; } $jobs = $this->getJobsByIds ( $jobIds ); if (! $jobs) { return array (); } $result = array (); foreach ( $jobs as $job ) { $result [] = array_merge ( $tmp [$job ['id']], $job ); } return $result; } function getJobsByIds($jobIds) { if ($this->_cache) { $jobs = $this->getFileCache (); if ($jobs) { $result = array (); foreach ( $jobs as $job ) { if (in_array ( $job ['id'], $jobIds )) { $result [] = $job; } } return $result; } } $jobDao = $this->_getJobDao (); return $jobDao->getByIds ( $jobIds ); } function getJoberByJobId($userId, $jobId) { $joberDao = $this->_getJoberDao (); return $joberDao->getByJobId ( $userId, $jobId ); } function countJoberByJobId($jobid) { $joberDao = $this->_getJoberDao (); return $joberDao->countByJobId ( $jobid ); } function _getJobDao() { $job = L::loadDB ( 'job', 'job' ); return $job; } function _getJoberDao() { $job = L::loadDB ( 'jober', 'job' ); return $job; } function _getJobDoerDao() { $job = L::loadDB ( 'jobdoer', 'job' ); return $job; } }! defined ( 'P_W' ) && exit ( 'Forbidden' ); class PW_JoberDB extends BaseDB { var $_tableName = "pw_jober"; function add($fieldData) { $this->_db->update ( "INSERT INTO " . $this->_tableName . " SET " . $this->_getUpdateSqlString ( $fieldData ) ); return $this->_db->insert_id (); } function update($fieldData, $id) { $this->_db->update ( "UPDATE " . $this->_tableName . " SET " . $this->_getUpdateSqlString ( $fieldData ) . " WHERE id=" . $this->_addSlashes ( $id ) . " LIMIT 1" ); return $this->_db->affected_rows (); } function delete($id) { $this->_db->update ( "DELETE FROM " . $this->_tableName . " WHERE id=" . $this->_addSlashes ( $id ) . " LIMIT 1" ); return $this->_db->affected_rows (); } function get($id) { $id = intval($id); if($id<1){ return null; } return $this->_db->get_one ( "SELECT * FROM " . $this->_tableName . " WHERE id=" . $this->_addSlashes ( $id ) . " LIMIT 1" ); } function getByJobId($userId,$jobId) { $userId = intval($userId); $jobId = intval($jobId); if($userId<1 || $jobId<1){ return null; } return $this->_db->get_one ( "SELECT * FROM " . $this->_tableName . " WHERE jobid=" . $this->_addSlashes ( $jobId ) . " AND userid =" . $this->_addSlashes ( $userId ) . " ORDER BY last DESC LIMIT 1" ); } function getAll() { $query = $this->_db->query ( "SELECT * FROM " . $this->_tableName ); return $this->_getAllResultFromQuery ( $query ); } function gets($offset,$limit) { $query = $this->_db->query ( "SELECT * FROM " . $this->_tableName. "  LIMIT " . $offset . "," . $limit ); return $this->_getAllResultFromQuery ( $query ); } function countByJobId($jobId){ $result = $this->_db->get_one ( "SELECT COUNT(*) AS total FROM " . $this->_tableName . " WHERE jobid=".$this->_addSlashes ( $jobId )."  LIMIT 1" ); return $result ['total']; } function getAppliedJobs($userid){ $userid = intval($userid); if($userid<1){ return null; } $query = $this->_db->query ( "SELECT * FROM " . $this->_tableName. " WHERE userid=".$this->_addSlashes ( $userid )." AND status<=2" ); return $this->_getAllResultFromQuery ( $query ); } function countAppliedJobs($userid){ $userid = intval($userid); if($userid<1){ return null; } return $this->_db->get_value ( "SELECT COUNT(*) as total FROM " . $this->_tableName. " WHERE userid=".$this->_addSlashes ( $userid )." AND status<2 LIMIT 1" ); } function getFinishJobs($userid){ $userid = intval($userid); if($userid<1){ return null; } $query = $this->_db->query ( "SELECT * FROM " . $this->_tableName. " WHERE userid=".$this->_addSlashes ( $userid )." AND total>0" ); return $this->_getAllResultFromQuery ( $query ); } function getQuitJobs($userid){ $userid = intval($userid); if($userid<1){ return null; } $query = $this->_db->query ( "SELECT * FROM " . $this->_tableName. " WHERE userid=".$this->_addSlashes ( $userid )." AND status>=4" ); return $this->_getAllResultFromQuery ( $query ); } function updateByJobId($fieldData, $jobid,$userid) { $userid = intval($userid); $jobid = intval($jobid); if($userid<1 || $jobid<1 ){ return null; } $this->_db->update ( "UPDATE " . $this->_tableName . " SET " . $this->_getUpdateSqlString ( $fieldData ) . "  WHERE jobid=" . $this->_addSlashes ( $jobid ) . " AND userid=" . $this->_addSlashes ( $userid ) . " LIMIT 1" ); return $this->_db->affected_rows (); }  function getsByJobIds($userid,$ids) { if(!is_array($ids)){ return array(); } $ids = implode(",",$ids); return $this->_db->get_one ( "SELECT * FROM " . $this->_tableName. "  WHERE jobid in(" .$ids. ") AND status <= 1 AND userid=".$this->_addSlashes ( $userid )." ORDER BY last DESC LIMIT 1" ); }  function getInProcessJobersByUserIdAndJobIds($userid, $ids) { $userid = (int) $userid; if(!S::isArray($ids) || $userid < 1) return array(); $query = $this->_db->query('SELECT * FROM ' . $this->_tableName . ' WHERE jobid IN(' . S::sqlImplode($ids) . ') AND status = 1 AND userid = ' . S::sqlEscape($userid) . ' ORDER BY last DESC'); return $this->_getAllResultFromQuery($query); } function getJobersByJobIds($userid,$ids) { $userid = intval($userid); if(!is_array($ids) || $userid<1 ){ return array(); } $ids = implode(",",$ids); $query = $this->_db->query ( "SELECT * FROM " . $this->_tableName. "  WHERE jobid in(" .$ids. ") AND userid=".$this->_addSlashes ( $userid )); return $this->_getAllResultFromQuery ( $query ); } function getJobersByJobIdAndUserId($userid,$jobid) { $userid = intval($userid); $jobid = intval($jobid); if($userid<1 || $jobid<1 ){ return null; } $query = $this->_db->query ( "SELECT * FROM " . $this->_tableName. "  WHERE jobid=" .$this->_addSlashes($jobid)." AND userid != ".$this->_addSlashes($userid)." AND total>0 LIMIT 20"); return $this->_getAllResultFromQuery ( $query ); } function countJobersByJobIdAndUserId($userid,$jobid) { $userid = intval($userid); $jobid = intval($jobid); if($userid<1 || $jobid<1 ){ return null; } $result = $this->_db->get_one ( "SELECT COUNT(*) as total FROM " . $this->_tableName. "  WHERE jobid=" .$this->_addSlashes($jobid)." AND userid != ".$this->_addSlashes($userid)." AND total>0"); return $result['total']; } } !defined('P_W') && exit('Forbidden');  class PW_Errors { var $_errors = array();  var $_logs = array();   function addError($errorInfo) { $this->_errors[] = $errorInfo; }  function addLog($logInfo) { $this->_logs[] = $logInfo; }  function writeLog($method = 'rb+') { $logFile = D_P.'data/error.log'; if (!$this->_logs) return false; $temp = pw_var_export($this->_logs); pwCache::writeover($logFile,$temp, 'rb+'); }  function checkError($jumpurl = '') { foreach ($this->_errors as $error) { $this->showError($error,$jumpurl); } }  function showError($error, $jumpurl = '') { Showmsg($error, $jumpurl); } function __destruct() { if (!defined('SHOWLOG')) return false; $this->writeLog(); } }! defined ( 'P_W' ) && exit ( 'Forbidden' ); class GatherCache_PW_Threads_Cache extends GatherCache_Base_Cache { var $_defaultCache = PW_CACHE_MEMCACHE; var $_prefix = 'thread_';  function getThreadByThreadId($threadId) { $threadId = S::int($threadId); if ($threadId < 1) return false; if (! $this->checkMemcache()) { return $this->_getThreadNoCache($threadId); } $key = $this->_getKeyForThread($threadId); $result = $this->_cacheService->get($key); if ($result === false) { $result = $this->_getThreadNoCache($threadId); $this->_cacheService->set($key, $result); } return $result; }  function getThreadsByThreadIds($threadIds) { if (! S::isArray ( $threadIds )) { return array(); } if (!$this->checkMemcache()) { return $this->_getThreadsNoCache($threadIds); } $result = $resultInCache = $resultInDb = $keys = $_cachedThreadIds = array (); foreach ( $threadIds as $threadId ) { $keys [] = $this->_getKeyForThread ( $threadId ); } if (($threads = $this->_cacheService->get ( $keys ))) { foreach ( $threads as $value ) { $_cachedThreadIds [] = $value ['tid']; $resultInCache [$value ['tid']] = $value; } } $_noCachedThreadIds = array_diff ( $threadIds, $_cachedThreadIds ); if ($_noCachedThreadIds && ($resultInDb = $this->_getThreadsNoCache ( $_noCachedThreadIds ))) { foreach ( $resultInDb as $value ) { $this->_cacheService->set ( $this->_getKeyForThread ( $value ['tid'] ), $value ); } } $tmpResult = (array)$resultInCache + (array)$resultInDb; foreach ($threadIds as $threadId){ $result[$threadId] = isset($tmpResult[$threadId]) ? $tmpResult[$threadId] : false; } return $result; }  function getThreadAndTmsgByThreadId($threadId) { $threadId = S::int($threadId); if ($threadId < 1) return false; if (! $this->checkMemcache ()) { return $this->_getThreadAndTmsgByThreadIdNoCache($threadId); } $threadKey = $this->_getKeyForThread($threadId); $tmsgKey = $this->_getKeyForTmsg($threadId);    $thread = $this->_cacheService->get($threadKey); $tmsg = $this->_cacheService->get($tmsgKey); if ($thread === false){ $thread = $this->_getThreadNoCache($threadId); $this->_cacheService->set($threadKey, $thread); } if ($tmsg === false){ $tmsg = $this->_getTmsgNoCache($threadId); $this->_cacheService->set($tmsgKey, $tmsg); } return ($thread && $tmsg) ? array_merge($thread, $tmsg) : array(); }  function getThreadListByForumId($forumId, $offset, $limit) { if (! $this->checkMemcache ()) { return $this->_getThreadListNoCache($forumId, $offset, $limit); } $key = $this->_getKeyForThreadList($forumId, $offset, $limit); $threadListIds = $this->_cacheService->get($key); if (!$threadListIds && ($threadList = $this->_getThreadListNoCache($forumId, $offset, $limit))) { $this->_cacheService->set($key, array_keys($threadList)); } return $threadList ? $threadList : $this->getThreadsByThreadIds($threadListIds); }  function clearCacheForThreadByThreadIds($threadIds){ $threadIds = (array) $threadIds; foreach ($threadIds as $tid){ $this->_cacheService->delete($this->_getKeyForThread($tid)); } return true; }  function clearCacheForTmsgByThreadIds($threadIds){ $threadIds = (array) $threadIds; foreach ($threadIds as $tid){ $this->_cacheService->delete($this->_getKeyForTmsg($tid)); } return true; }  function clearCacheForThreadListByForumIds($forumIds){ $forumIds = (array) $forumIds; foreach ($forumIds as $forumId){ $this->_cacheService->increment($this->_getKeyForForumVersion($forumId)); } return true; }  function _getKeyForThread($threadId) { return $this->_prefix . 'tid_' . $threadId; }  function _getKeyForThreadList($forumId, $offset, $limit){ return $this->_prefix . 'fid_' . $forumId . '_offset_' . $offset . '_limit_' . $limit . '_ver_' . $this->_getForumVersionId($forumId); }  function _getKeyForTmsg($threadId){ return $this->_prefix . 'tmsg_tid_' . $threadId; }  function _getKeyForForumVersion($forumId){ return $this->_prefix . 'forumversion_' . $forumId; }  function _getForumVersionId($forumId){ $key = $this->_getKeyForForumVersion($forumId); $versionId = $this->_cacheService->get($key); if (!$versionId){ $versionId = 1; $this->_cacheService->set($key, $versionId, 3600*24); } return $versionId; }  function _getThreadNoCache($threadId) { $_dbService = L::loadDB('threads', 'forum'); return $_dbService->getThreadByThreadId ( $threadId ); }  function _getTmsgNoCache($threadIds){ $_dbService = L::loadDB('threads', 'forum'); return $_dbService->getTmsgByThreadId($threadIds); }  function _getThreadsNoCache($threadIds) { $_dbService = L::loadDB('threads', 'forum'); return $_dbService->getThreadsByThreadIds($threadIds); }  function _getThreadListNoCache($forumId, $offset, $limit){ $_dbService = L::loadDB('threads', 'forum'); return $_dbService->getThreadsByFroumId($forumId, $offset, $limit); }  function _getThreadAndTmsgByThreadIdNoCache($threadId){ $_dbService = L::loadDB('threads', 'forum'); return $_dbService->getThreadAndTmsgByThreadId($threadId); } }