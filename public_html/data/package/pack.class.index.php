<?php
! defined ( 'P_W' ) && exit ( 'Forbidden' );  define ( 'PW_CACHE_VERSION', '1.0.0' ); define ( 'PW_CACHE_DIR', R_P . 'lib/utility' ); define ( 'PW_CACHE_CONFIG', 'cache_config' ); ! defined ( 'PW_CACHE_MEMCACHE' ) && define ( 'PW_CACHE_MEMCACHE', 'memcache' ); ! defined ( 'PW_CACHE_FILECACHE' ) && define ( 'PW_CACHE_FILECACHE', 'filecache' ); ! defined ( 'PW_CACHE_DBCACHE' ) && define ( 'PW_CACHE_DBCACHE', 'dbcache' ); class PW_CacheService { var $_services = array (); function PW_CacheService() { $this->__construct (); }  function __construct() { if (! isset ( $this->_services [PW_CACHE_CONFIG] ) || ! $this->_services [PW_CACHE_CONFIG]) { $this->_services [PW_CACHE_CONFIG] = new Cache_ServiceFactory (); } }  function set($key, $value, $expire = 600, $cacheName = null) { if (! ($cacheService = $this->_services [PW_CACHE_CONFIG]->getService ( $cacheName ))) { return false; } return $cacheService->set ( $key, $value, $expire ); }  function get($key, $cacheName = null) { if (! ($cacheService = $this->_services [PW_CACHE_CONFIG]->getService ( $cacheName ))) { return false; } return $cacheService->get ( $key ); }  function delete($key, $cacheName = null) { if (! ($cacheService = $this->_services [PW_CACHE_CONFIG]->getService ( $cacheName ))) { return false; } return $cacheService->delete ( $key ); } function increment($key, $value = 1, $cacheName = null) { if (! ($cacheService = $this->_services [PW_CACHE_CONFIG]->getService ( $cacheName ))) { return false; } return $cacheService->increment ( $key, $value ); }  function flush($cacheName = null) { if (! ($cacheService = $this->_services [PW_CACHE_CONFIG]->getService ( $cacheName ))) { return false; } return $cacheService->flush (); } }  class Cache_ServiceFactory { var $_defaultService = null; var $_services = array (); function Cache_ServiceFactory() { $this->__construct (); } function __construct() { $this->_defaultService = $this->build ( Cache_Config_Default::defaultCache () ); } function build($cacheName) { switch ($cacheName) { case PW_CACHE_MEMCACHE : return $this->getMemcacheService (); case PW_CACHE_FILECACHE : return $this->getFilecacheService (); case PW_CACHE_DBCACHE : return $this->getDbCacheService (); default : return false; } } function getService($cacheName) { return ($cacheName) ? $this->build ( $cacheName ) : $this->_defaultService; }  function getMemcacheService() { if (! isset ( $this->_services [PW_CACHE_MEMCACHE] ) || ! $this->_services [PW_CACHE_MEMCACHE]) { $this->_services [PW_CACHE_MEMCACHE] = new PW_MemcacheService (); } return $this->_services [PW_CACHE_MEMCACHE]; }  function getFilecacheService() { if (! isset ( $this->_services [PW_CACHE_FILECACHE] ) || ! $this->_services [PW_CACHE_FILECACHE]) { $this->_services [PW_CACHE_FILECACHE] = new PW_FilecacheService (); } return $this->_services [PW_CACHE_FILECACHE]; }  function getDbCacheService() { if (! isset ( $this->_services [PW_CACHE_DBCACHE] ) || ! $this->_services [PW_CACHE_DBCACHE]) { $this->_services [PW_CACHE_DBCACHE] = new PW_DbcacheService (); } return $this->_services [PW_CACHE_DBCACHE]; } }  class Cache_Config_Default {  function defaultCache() { return PW_CACHE_MEMCACHE; }  function getUnique() { return $GLOBALS['db_memcache']['hash']; } function getCurrentTime() { return $GLOBALS ['timestamp']; } }  class Cache_Config_Memcache {  function load() { return ($GLOBALS ['db_memcache']) ? array ($GLOBALS ['db_memcache'] ) : array (array ('host' => 'localhost', 'port' => 11211 ) ); } }  class Cache_Config_Filecache {  function getDirectory() { return D_P . 'data/gathercache/'; }  function getExt() { return '.php'; }  function createFile($key) { return Cache_Config_Filecache::getDirectory () . Cache_Config_Default::getUnique () . $key . Cache_Config_Filecache::getExt (); }  function readFile($fileName, $method = 'rb') { return readover ( $fileName, $method ); }  function writeFile($fileName, $data, $method = 'rb+', $ifLock = true, $ifCheckPath = true, $ifChmod = true) { return writeover ( $fileName, $data, $method, $ifLock, $ifCheckPath, $ifChmod ); } }  class Cache_Config_Dbcache { function connect() { $tmp = $GLOBALS ['db']->getMastdb(); return $tmp->sql; }  function getTable($key = null) { return 'pw_cache_storage'; } function createTable() {  } }  class PW_MemcacheService { var $_object = null; function PW_MemcacheService() { $this->__construct (); } function __construct() { $this->_load (); }  function set($key, $value, $expire = 600) { return (! $this->_check ()) ? false : $this->_object->set ( $this->_hash ( $key ), $value, 0, $expire ); } function increment($key, $value = 1) { return (! $this->_check ()) ? false : $this->_object->increment ( $this->_hash ( $key ), $value ); }  function get($key) { return (! $this->_check ()) ? false : $this->_object->get ( $this->_hash ( $key ) ); }  function delete($key) { return (! $this->_check ()) ? false : $this->_object->delete ( $this->_hash ( $key ) ); }  function flush() { return (! $this->_check ()) ? false : $this->_object->flush (); }  function close() { return (! $this->_check ()) ? false : $this->_object->close (); }  function _hash($key) { $unique = Cache_Config_Default::getUnique (); if (! is_array ( $key )) { return $unique . $key; } $_tmpKey = array (); foreach ( $key as $k ) { $_tmpKey [] = $unique . $k; } return $_tmpKey; }  function _check() { return (is_object ( $this->_object )) ? true : false; }  function _load() { if (! class_exists ( 'memcache' ) || ! ($configs = $this->_config ())) { return false; } $this->_object = new Memcache (); if (method_exists ( $this->_object, 'addServer' )) { foreach ( $configs as $config ) { $this->_object->addServer ( $config ['host'], $config ['port'] ); } } else { $this->_object->connect ( $configs [0] ['host'], $configs [0] ['port'] ); } }  function _config() { return Cache_Config_Memcache::load (); } }  class PW_FilecacheService { var $_object = null; function PW_FilecacheService() { $this->__construct (); } function __construct() { $this->_load (); }  function set($key, $value, $expire = 600) { return ($this->_check ()) ? $this->_object->write ( $this->_hash ( $key ), $value, $expire ) : false; }  function get($key) { return ($this->_check ()) ? $this->_object->read ( $this->_hash ( $key ) ) : false; }  function delete($key) { return ($this->_check ()) ? $this->_object->delete ( $this->_hash ( $key ) ) : false; }  function flush() { return ($this->_check ()) ? $this->_object->flush () : false; } function increment($key, $value = 1) { }  function _hash($key) { if (! is_array ( $key )) { return $key; } $_tmp = array (); foreach ( $key as $k ) { $_tmp [] = $k; } return $_tmp; }  function _load() { if (! $this->_object) { $this->_object = new Cache_File_OperateService (); } }  function _check() { return (is_object ( $this->_object )) ? true : false; } }  class Cache_File_OperateService {  function read($key, $method = 'rb') { if (! is_array ( $key )) { return $this->_read ( $key, $method ); } $_tmpData = array (); foreach ( $key as $k ) { $_tmpData [$k] = $this->_read ( $k, $method ); } return $_tmpData; } function _read($key, $method = 'rb') { if (! ($fileName = Cache_Config_Filecache::createFile ( $key ))) { return array (); } $data = unserialize ( Cache_Config_Filecache::readFile ( $fileName, $method ) ); $currentTime = Cache_Config_Default::getCurrentTime (); if (! $data || $data ['expire'] < $currentTime) { $this->delete ( $key ); return array (); } return $data ['value']; }  function write($key, $value, $expire = 600) { $fileName = Cache_Config_Filecache::createFile ( $key ); $expire = Cache_Config_Default::getCurrentTime () + $expire; return Cache_Config_Filecache::writeFile ( $fileName, serialize ( array ('expire' => $expire, 'value' => $value ) ) ); }  function delete($key) { $fileName = Cache_Config_Filecache::createFile ( $key ); if (! is_file ( $fileName )) return false; P_unlink ( $fileName ); }  function flush() { $directory = Cache_Config_Filecache::getDirectory (); if (! is_dir ( $directory )) { return false; } if (! ($dh = opendir ( $directory ))) { return false; } while ( (($file = readdir ( $dh )) !== false) ) { if (in_array ( $file, array ('.', '..' ) )) continue; $this->delete ( $directory . $file ); } closedir ( $dh ); } }  class PW_DbcacheService { var $_object = null; function PW_DbcacheService() { $this->__construct (); } function __construct() { $this->_load (); }  function set($key, $value, $expire = 600) { return ($this->_check ()) ? $this->_object->insert ( $this->_hash ( $key ), $value, $expire ) : false; }  function get($key) { return ($this->_check ()) ? $this->_object->get ( $this->_hash ( $key ) ) : false; }  function delete($key) { return ($this->_check ()) ? $this->_object->delete ( $this->_hash ( $key ) ) : false; }  function flush() { return ($this->_check ()) ? $this->_object->flush () : false; } function increment($key, $value = 1) { }  function _hash($key) { $unique = Cache_Config_Default::getUnique (); if (! is_array ( $key )) { return $unique . $key; } $_tmp = array (); foreach ( $key as $k ) { $_tmp [] = $unique . $k; } return $_tmp; }  function _load() { if (! $this->_object) { $this->_object = new Cache_Db_OperateService (); } }  function _check() { return (is_object ( $this->_object )) ? true : false; } }  class Cache_Db_OperateService { var $_conn = NULL; function Cache_Db_OperateService() { $this->__construct (); } function __construct() { $this->_conn = $this->connect (); }  function insert($key, $value, $expire = 600) { $expire = Cache_Config_Default::getCurrentTime () + $expire; return $this->query ( "REPLACE INTO " . $this->getTableName ( $key ) . " (ckey,cvalue,expire) VALUES (" . $this->escape ( $key ) . "," . $this->escape ( serialize ( $value ) ) . "," . $this->escape ( $expire ) . ")" ); }  function get($key) { $key = (is_array ( $key )) ? $key : array ($key ); $currentTime = Cache_Config_Default::getCurrentTime (); $query = $this->query ( "SELECT ckey,cvalue FROM " . $this->getTableName ( $key ) . " WHERE ckey IN ( " . $this->escape ( $key ) . ") AND expire >= " . $this->escape ( $currentTime ) ); $result = $this->fetchArray ( $query ); return $result; }  function delete($key) { $key = (is_array ( $key )) ? $key : array ($key ); return $this->query ( "DELETE FROM " . $this->getTableName ( $key ) . " WHERE ckey IN( " . $this->escape ( $key ) . ")" ); }  function flush() { return $this->query ( "TRUNCATE TABLE " . $this->getTableName () ); }  function query($sql) { return mysql_query ( $sql, $this->_conn ); }  function escape($key) { if (! is_array ( $key )) { return "'" . $key . "'"; } $_tmp = ''; foreach ( $key as $k ) { $_tmp .= (($_tmp) ? ',' : '') . "'" . $k . "'"; } return $_tmp; }  function fetchArray($result, $type = MYSQL_ASSOC) { $rt = array (); while ( $row = mysql_fetch_array ( $result, $type ) ) { $rt [$row ['ckey']] = unserialize ( $row ['cvalue'] ); } return $rt; }  function getTableName($key = null) { return Cache_Config_Dbcache::getTable ( $key ); }  function connect() { return Cache_Config_Dbcache::connect (); } }! defined ( 'P_W' ) && exit ( 'Forbidden' );  define ( 'PW_UPDATE', 'update' ); define ( 'PW_SELECT', 'select' ); define ( 'PW_DELETE', 'delete' ); define ( 'PW_INSERT', 'insert' ); define ( 'PW_REPLACE', 'replace' ); class PW_Gather {  function spreadCache($cacheName) { if (! $cacheName) return false; return $this->_loadGatherCache ( $cacheName ); }  function spreadQuery($operate, $tableNames, $fields, $expand = array()) { if (! S::isArray ( $tableNames )) { return false; } foreach ( $tableNames as $tableName ) { $this->_loadGatherQuery ( $operate, $tableName, $fields, $expand ); } return true; }  function spreadInfo($gatherName, $information = null, $defaultName = 'general') { if (! $gatherName) return false; return $this->_loadGatherInfo ( $gatherName, $information ); } function _loadGatherCache($cacheName) { static $_cacheNames = null; $cacheName = strtolower ( $cacheName ); if (! isset ( $_cacheNames [$cacheName] )) { $filePath = R_P . "lib/gather/gathercache/" . $cacheName . ".cache.php"; if (! is_file ( $filePath )) return false;  $className = 'GatherCache_' . $cacheName . '_Cache'; $filePath = pwPack::classPath ( $filePath, $className );  require_once S::escapePath ( $filePath );  if (! class_exists ( $className )) { return false; } $_cacheNames [$cacheName] = &new $className (); } return $_cacheNames [$cacheName]; } function _loadGatherQuery($operate, $tableName, $fields, $expand) { static $_classes = null; $tmpTableName = $tableName = strtolower ( $tableName ); $tableName = $this->_convertTableName ( $tableName ); if (! isset ( $_classes [$tableName] )) { $filePath = R_P . "lib/gather/gatherquery/" . $tableName . ".query.php"; if (! is_file ( $filePath )) return false; require_once S::escapePath ( $filePath ); $className = 'GatherQuery_UserDefine_' . $tableName; if (! class_exists ( $className )) { return false; } $_classes [$tableName] = &new $className (); } return $this->dispatchQuery ( $_classes [$tableName], $operate, $tmpTableName, $fields, $expand ); } function dispatchQuery($userDefineClass, $operate, $tableName, $fields, $expand = array()) { if (! S::isObj ( $userDefineClass ) || ! $operate || ! S::isArray ( $fields )) { return false; } $userDefineClass->init (); switch (strtolower ( $operate )) { case 'insert' : $userDefineClass->insert ( $tableName, $fields, $expand ); break; case 'replace' : $userDefineClass->insert ( $tableName, $fields, $expand ); break; case 'select' : $userDefineClass->select ( $tableName, $fields, $expand ); break; case 'update' : $userDefineClass->update ( $tableName, $fields, $expand ); break; case 'delete' : $userDefineClass->delete ( $tableName, $fields, $expand ); break; default : break; } return true; } function _loadGatherInfo($gatherName, $information, $defaultName = 'general') { $filePath = R_P . "lib/gather/gatherinfo/" . $defaultName . ".service.php"; if (! is_file ( $filePath )) return false; require_once S::escapePath ( $filePath ); $className = 'GatherInfo_' . $defaultName . '_Service'; if (! class_exists ( $className ) || ! is_callable ( array ($className, $gatherName ) )) { return false; } $object = &new $className (); return $object->$gatherName ( $information ); } function _convertTableName($tablename) { $extendTableNames = array (); if ($GLOBALS ['db_tlist']) { foreach ( $GLOBALS ['db_tlist'] as $k => $v ) { $extendTableNames ['pw_tmsgs' . ($k ? $k : '')] = 'pw_threads'; } } if ($GLOBALS ['db_plist']) { foreach ( $GLOBALS ['db_plist'] as $k => $v ) { $extendTableNames ['pw_posts' . ($k ? $k : '')] = 'pw_posts'; } } $tableNames = array ('pw_tmsgs' => 'pw_threads', 'pw_memberinfo' => 'pw_members', 'pw_memberdata' => 'pw_members', 'pw_singleright' => 'pw_members', 'pw_membercredit' => 'pw_members', 'pw_banuser' => 'pw_members', 'pw_cmembers' => 'pw_members', 'pw_membertags_relations' => 'pw_members', 'pw_forumdata' => 'pw_forums', 'pw_announce' => 'pw_forums'); $tableNames += $extendTableNames; return (isset ( $tableNames [$tablename] )) ? $tableNames [$tablename] : $tablename; } } class GatherCache_Base_Cache { var $_cacheService = null; function GatherCache_Base_Cache() { $this->__construct (); } function __construct() { $this->_cacheService = ($this->_cacheService) ? $this->_cacheService : $this->getCacheService (); } function checkMemcache() { static $isMemcache = null; if (! isset ( $isMemcache )) { $isMemcache = class_exists ( "Memcache" ) && strtolower ( $GLOBALS ['db_datastore'] ) == 'memcache'; } return $isMemcache; } function getUnique() { return $GLOBALS ['db_memcache'] ['hash']; } function getCacheService() { return L::loadClass ( 'cacheservice', 'utility' ); } }!defined('P_W') && exit('Forbidden'); class PW_MembersDB extends BaseDB { var $_tableName = "pw_members"; var $_memberDataTableName = "pw_memberdata"; var $_memberInfoTableName = "pw_memberinfo"; var $_singleRightTableName = 'pw_singleright'; var $_userEducation = 'pw_user_education'; var $_userCareer = 'pw_user_career'; var $_primaryKey = 'uid'; function get($id) { return $this->_get($id); } function getWithJoin($userId, $withMainTable = true, $withMemberDataTable = false, $withMemberInfoTable = false) { $userId = intval($userId); if ($userId <= 0) return null; if (!$withMainTable && !$withMemberDataTable && !$withMemberInfoTable) return null; $tables = array('a' => $this->_tableName, 'b' => $this->_memberDataTableName, 'c' => $this->_memberInfoTableName); $selects = array('a' => $withMainTable, 'b' => $withMemberDataTable, 'c' => $withMemberInfoTable); $fields = array(); $firstTable = null; $firstAlias = null; $leftJoins = array(); foreach ($tables as $alias => $tableName) { if (!$selects[$alias]) continue; $fields[$alias] = $alias . ".*"; if (null === $firstTable) { $firstTable = $tableName; $firstAlias = $alias; } else { $leftJoins[] = " LEFT JOIN " . $tableName . " AS " . $alias . " ON " . $firstAlias . ".uid=" . $alias . ".uid "; } } if ($withMemberDataTable && $withMemberInfoTable) {  unset($fields['b']); $fields['b'] = "b.*, c.credit AS creditinfo"; } return $this->_db->get_one("SELECT " . implode(',', $fields) . " FROM " . $firstTable . " AS " . $firstAlias . " " . implode(' ', $leftJoins) . " WHERE " . $firstAlias . ".uid=" . $this->_addSlashes($userId)); } function insert($fieldData) { return $this->_insert($fieldData); } function update($fieldData, $id) { return $this->_update($fieldData, $id); } function updates($fieldData, $ids) { if (!$this->_check() || !$fieldData || empty($ids)) return false;  pwQuery::update('pw_members', "uid IN(:uid)" , array($ids), $fieldData); return $this->_db->affected_rows(); } function increase($userId, $increments) { $userId = intval($userId); if ($userId <= 0 || !is_array($increments)) return 0; $incrementStatement = array(); foreach ($increments as $field => $offset) { $offset = intval($offset); if (!$offset) continue; if ($offset<0){ $incrementStatement[] = $field . "=" . $field . $offset; }else{ $incrementStatement[] = $field . "=" . $field . "+" . $offset; } } if (empty($incrementStatement)) return 0;  $this->_db->update(pwQuery::buildClause("UPDATE :pw_table SET " . implode(", ", $incrementStatement) . " WHERE uid=:uid", array($this->_tableName, $userId))); return $this->_db->affected_rows(); } function delete($id) { return $this->_delete($id); } function count() { return $this->_count(); }  function setUserStatus($userId, $bit, $status = true, $num = 1) { list($userId, $bit, $num) = array(intval($userId), intval($bit), intval($num)); if ($userId <= 0 || $bit <= 0 || $num <= 0) return false; $status = sprintf('%0' . $num . 'b', $status);  --$bit; $userstatus = array(); $userstatus[] = '&~((pow(2, ' . $num . ') - 1)<<' . $bit . ')';  for ($i = $num - 1; $i >= 0; $i--) { if (isset($status[$i]) && $status[$i]) { $userstatus[] = '|(1<<' . $bit . ')'; } else { $userstatus[] = '&~(1<<' . $bit . ')'; } ++$bit; } $userstatus = 'userstatus=userstatus' . implode('', $userstatus);  $this->_db->update(pwQuery::buildClause("UPDATE :pw_table SET $userstatus WHERE uid=:uid", array($this->_tableName, $userId))); return $this->_db->affected_rows(); } function getUsersByUserNames($userNames) { $query = $this->_db->query("SELECT * FROM " . $this->_tableName . " WHERE username IN(" . S::sqlImplode($userNames) . ")"); return $this->_getAllResultFromQuery($query); } function getUsersByUserIds($userIds) { $query = $this->_db->query("SELECT * FROM " . $this->_tableName . " WHERE uid IN(" . S::sqlImplode($userIds) . ")"); return $this->_getAllResultFromQuery($query, 'uid'); } function getUserByUserName($userName, $fields = '*') { if (!$userName) return false; return $this->_db->get_one("SELECT $fields FROM " . $this->_tableName . " WHERE username = " . $this->_addSlashes($userName)); }  function getUserByUserEmails($emails) { $query = $this->_db->query("SELECT * FROM " . $this->_tableName . " WHERE email IN (" . S::sqlImplode($emails) . ")"); return $this->_getAllResultFromQuery($query); }  function getUsersByGroupIds($groupIds) { $query = $this->_db->query("SELECT * FROM " . $this->_tableName . " WHERE groupid IN(" . S::sqlImplode($groupIds) . ")"); return $this->_getAllResultFromQuery($query); }  function getUsersByGroupId($groupId) { $query = $this->_db->query("SELECT * FROM " . $this->_tableName . " WHERE groupid = " . $this->_addSlashes($groupId)); return $this->_getAllResultFromQuery($query); } function getUserInfosByUserIds($userIds) { $userIds = (is_array($userIds)) ? S::sqlImplode($userIds) : $userIds; $query = $this->_db->query("SELECT * FROM " . $this->_tableName . " m LEFT JOIN " . $this->_memberDataTableName . " md ON m.uid=md.uid WHERE m.uid IN(" . $userIds . ")"); return $this->_getAllResultFromQuery($query, 'uid'); } function findUsersOrderByUserId($limit = 1) { $limit = intval($limit); if ($limit <= 0) return array(); $query = $this->_db->query("SELECT * FROM " . $this->_tableName . " ORDER BY uid DESC LIMIT " . $limit); return $this->_getAllResultFromQuery($query); } function findNotBannedUsersOrderByUserId($limit = 1) { global $db_uidblacklist; $limit = intval($limit); if ($limit <= 0) return array(); $db_uidblacklist && $sqlWhere .= ' AND uid NOT IN (' . $db_uidblacklist . ')'; $query = $this->_db->query("SELECT * FROM " . $this->_tableName . " WHERE groupid <> 6 ".$sqlWhere." ORDER BY uid DESC LIMIT " . $limit); return $this->_getAllResultFromQuery($query); }  function countSearch($keywords) { $result = $this->_db->get_one("SELECT COUNT(*) as total FROM " . $this->_tableName . " WHERE username like " . S::sqlEscape("%$keywords%") . " LIMIT 1"); return ($result) ? $result['total'] : 0; }  function getSearch($keywords, $offset, $limit) { $query = $this->_db->query("SELECT * FROM " . $this->_tableName . " WHERE username like " . S::sqlEscape("%$keywords%") . " LIMIT " . $offset . "," . $limit); return $this->_getAllResultFromQuery($query); } function getMemberAndData($userIds){ $query = $this->_db->query("SELECT m.uid,m.username,m.gender,m.oicq,m.aliww,m.groupid,m.memberid,m.icon AS micon ,m.hack,m.honor,m.signature,m.regdate,m.medals,m.userstatus,md.postnum,md.digests,md.rvrc,md.money,md.credit,md.currency,md.thisvisit,md.lastvisit,md.onlinetime,md.starttime FROM pw_members m LEFT JOIN pw_memberdata md ON m.uid=md.uid WHERE m.uid IN (".S::sqlImplode($userIds).") "); return $this->_getAllResultFromQuery($query); } function getLatestUsersCount() { $total = $this->_db->get_value("SELECT COUNT(*) as total FROM " . $this->_tableName . " LIMIT 1"); return ($total<500) ? $total :500; } function getLatestUsers($offset, $limit) { $query = $this->_db->query ("SELECT * FROM ".$this->_tableName." ORDER BY uid DESC " .$this->_Limit($offset, $limit)); return $this->_getAllResultFromQuery ( $query ); } function getMembersAndMemberDataAndMemberInfoByUserIds($userIds, $fieldinfo = ''){ $query = $this->_db->query ( "SELECT m.*, m.icon AS micon,
		md.uid as `md.uid`, md.lastmsg,md.postnum,md.rvrc,md.money,md.credit,md.currency,md.lastvisit,md.thisvisit,md.onlinetime,md.lastpost,md.todaypost,
		md.monthpost,md.onlineip,md.uploadtime,md.uploadnum,md.starttime,md.pwdctime,md.monoltime,md.digests,md.f_num,md.creditpop,
		md.jobnum,md.lastgrab,md.follows,md.fans,md.newfans,md.newreferto,md.newcomment,md.postcheck,md.punch,md.shafa,md.newnotice,md.newrequest,md.bubble,
		mi.customdata $fieldinfo FROM pw_members m LEFT JOIN pw_memberdata md ON m.uid=md.uid LEFT JOIN pw_memberinfo mi ON mi.uid=m.uid 
		WHERE m.uid IN (".S::sqlImplode($userIds,false).")" ); return $this->_getAllResultFromQuery ( $query, 'uid' ); }  function countUsersByApartmentAndUserIds($apartment,$userIds) { $apartment = intval($apartment); if ($apartment < 1 || !s::isArray($userIds)) return 0; return $this->_db->get_value("SELECT COUNT(*) FROM " . $this->_tableName . " m LEFT JOIN " . $this->_memberDataTableName. " md USING(uid) WHERE m.uid IN(" . S::sqlImplode($userIds) . ") AND m.apartment = " . $this->_addSlashes($apartment)); }  function getUsersByApartmentAndUserIds($apartment,$userIds,$num) { $apartment = intval($apartment); $num = intval($num); if ($apartment < 1 || $num < 1 || !s::isArray($userIds)) return array(); $query = $this->_db->query("SELECT m.uid FROM " . $this->_tableName . " m LEFT JOIN " . $this->_memberDataTableName. " md USING(uid) WHERE m.uid IN(" . S::sqlImplode($userIds) . ") AND m.apartment = " . $this->_addSlashes($apartment) . ' ' . $this->_Limit(0, $num)); return $this->_getAllResultFromQuery($query); }  function countUsersByHomeAndUserIds($home,$userIds) { $home = intval($home); if ($home < 1 || !s::isArray($userIds)) return 0; return $this->_db->get_value("SELECT COUNT(*) FROM " . $this->_tableName . " m LEFT JOIN " . $this->_memberDataTableName. " md USING(uid) WHERE m.uid IN(" . S::sqlImplode($userIds) . ") AND m.home = " . $this->_addSlashes($home)); }  function getUsersByHomeAndUserIds($home,$userIds,$num) { $home = intval($home); if ($home < 1 || !s::isArray($userIds)) return array(); $query = $this->_db->query("SELECT m.uid FROM " . $this->_tableName . " m LEFT JOIN " . $this->_memberDataTableName. " md USING(uid) WHERE m.uid IN(" . S::sqlImplode($userIds) . ") AND m.home = " . $this->_addSlashes($home) . " " . $this->_Limit(0, $num)); return $this->_getAllResultFromQuery($query); }  function countUsersByCompanyidAndUserIds($companyids,$userIds) { if (!s::isArray($companyids) || !s::isArray($userIds)) return 0; return $this->_db->get_value("SELECT COUNT(*) FROM " . $this->_tableName . " m LEFT JOIN " . $this->_memberDataTableName. " md USING(uid) LEFT JOIN " . $this->_userCareer. " mc USING(uid) WHERE m.uid IN(" . S::sqlImplode($userIds) . ") AND mc.companyid IN(" . S::sqlImplode($companyids) . ")"); }  function getUsersByCompanyidAndUserIds($companyids,$userIds,$num) { if (!s::isArray($companyids) || !s::isArray($userIds)) return array(); $query = $this->_db->query("SELECT m.uid FROM " . $this->_tableName . " m LEFT JOIN " . $this->_memberDataTableName. " md USING(uid) LEFT JOIN " . $this->_userCareer. " mc USING(uid) WHERE m.uid IN(" . S::sqlImplode($userIds) . ") AND mc.companyid IN(" . S::sqlImplode($companyids) . ") " . $this->_Limit(0, $num)); return $this->_getAllResultFromQuery($query); }  function countUsersBySchoolidsAndUserIds($schoolids,$userIds) { if (!s::isArray($schoolids) || !s::isArray($userIds)) return 0; return $this->_db->get_value("SELECT COUNT(*) FROM " . $this->_tableName . " m LEFT JOIN " . $this->_memberDataTableName. " md USING(uid) LEFT JOIN " . $this->_userEducation. " me USING(uid) WHERE m.uid IN(" . S::sqlImplode($userIds) . ") AND me.schoolid IN(" . S::sqlImplode($schoolids) . ")"); }  function getUsersBySchoolidsAndUserIds($schoolids,$userIds,$num) { if (!s::isArray($schoolids) || !s::isArray($userIds)) return array(); $query = $this->_db->query("SELECT m.uid FROM " . $this->_tableName . " m LEFT JOIN " . $this->_memberDataTableName. " md USING(uid) LEFT JOIN " . $this->_userEducation. " me USING(uid) WHERE m.uid IN(" . S::sqlImplode($userIds) . ") AND me.schoolid IN(" . S::sqlImplode($schoolids) . ") " . $this->_Limit(0, $num)); return $this->_getAllResultFromQuery($query); }  function getUserInfoByUserId($userId) { $userId = intval($userId); if ($userId < 1) return array(); return $this->_db->get_one("SELECT m.uid,m.apartment,m.home,me.schoolid,mc.companyid FROM " . $this->_tableName . " m LEFT JOIN " . $this->_userEducation. " me USING(uid) LEFT JOIN " . $this->_userCareer. " mc USING(uid) WHERE m.uid = " . $this->_addSlashes($userId)); }  } !defined('P_W') && exit('Forbidden'); class PW_SingleRightDB extends BaseDB { var $_tableName = "pw_singleright"; var $_primaryKey = 'uid'; function get($id) { return $this->_get($id); } } !defined('P_W') && exit('Forbidden'); define('PW_NAV_TYPE_MAIN', 'main'); define('PW_NAV_TYPE_HEAD_LEFT', 'head_left'); define('PW_NAV_TYPE_HEAD_RIGHT', 'head_right'); define('PW_NAV_TYPE_FOOT', 'foot');  class PW_NavConfig { function add($navType, $fieldsData) { if (!$this->_checkNavType($navType)) return 0; $navConfigDb = $this->_getNavConfigDB(); $fieldsData['type'] = $navType; isset($fieldsData['style']) && $fieldsData['style'] = $this->_encodeStyleField($fieldsData['style']); isset($fieldsData['pos']) && $fieldsData['pos'] = $this->_encodePosField($fieldsData['pos']); return $navConfigDb->add($fieldsData); } function get($navId) { $navConfigDb = $this->_getNavConfigDB(); $data = $navConfigDb->get($navId); if (!$data) return null; $data['style'] = $this->_decodeStyleField($data['style']); $data['pos'] = $this->_decodePosField($data['pos']); return $data; } function getByKey($navKey, $navType = '') { $navKey = trim($navKey); if ('' == $navKey) return null; $navConfigDb = $this->_getNavConfigDB(); return $navConfigDb->getByKey($navKey, $navType); } function update($navId, $fieldsData) { if ($navId <= 0) return 0; $navConfigDb = $this->_getNavConfigDB(); isset($fieldsData['style']) && $fieldsData['style'] = $this->_encodeStyleField($fieldsData['style']); isset($fieldsData['pos']) && $fieldsData['pos'] = $this->_encodePosField($fieldsData['pos']); return $navConfigDb->update($navId, $fieldsData); } function controlShowByKey($navKey, $isShow = false) { $navKey = trim($navKey); if ('' == $navKey) return 0; $navConfigDb = $this->_getNavConfigDB(); return $navConfigDb->updateByKey($navKey, array('isshow'=>$isShow ? 1 : 0)); } function delete($navId) { if ($navId <= 0) return 0; $navIds = array($navId); $navConfigDb = $this->_getNavConfigDB(); $data = $navConfigDb->get($navId); if (!$data) return 0; foreach ($navConfigDb->findSubNavsByType($data['type'], $navId) as $nav) { $navIds[] = $nav['nid']; } return $navConfigDb->deletes($navIds); } function deleteByType($navType) { if (!$this->_checkNavType($navType)) return array(); $navConfigDb = $this->_getNavConfigDB(); return $navConfigDb->deleteByType($navType); } function deleteByKey($navKey) { $navKey = trim($navKey); if ('' == $navKey) return 0; $navConfigDb = $this->_getNavConfigDB(); $exist = $navConfigDb->getByKey($navKey); if (!$exist) return 0; return $this->delete($exist['nid']); } function findNavListByType($navType) { if (!$this->_checkNavType($navType)) return array(); $navConfigDb = $this->_getNavConfigDB(); return $navConfigDb->findByType($navType); } function relateNavList($navList) { $relativeNavs = array(); foreach ($navList as $nav) { $nav['pos'] = $this->_decodePosField($nav['pos']); if ($nav['upid']) { $relativeNavs[$nav['upid']]['subs'][$nav['nid']] = $nav; } else { $relativeNavs[$nav['nid']]['data'] = $nav; } } return $relativeNavs; } function findSubNavListByType($navType, $parentNavId = 0) { if (!$this->_checkNavType($navType)) return array(); $navConfigDb = $this->_getNavConfigDB(); return $navConfigDb->findSubNavsByType($navType, $parentNavId); } function findNavConfigs(){ static $navConfigData = array(); if(!$navConfigData){  extract(pwCache::getData(D_P . 'data/bbscache/navcache.php',false));  } if(!$navConfigData){ $navConfigDb = $this->_getNavConfigDB(); $navConfigData = $navConfigDb->findNavConfigs(); } return $navConfigData; } function findValidNavListByTypeAndPostion($navType, $postion, $currentPostion = array()) { $relativeNavs = array(); $notValidParent = array(); $currentPostionsKeeper = array(); $navConfigData = $this->findNavConfigs(); foreach ((array)$navConfigData[$navType] as $nav) { if (!$nav['isshow']) continue; $nav['iscurrent'] = false; $nav['pos'] = $this->_decodePosField($nav['pos']); $nav['style'] = $this->_decodeStyleField($nav['style']); if ($nav['upid']) { $relativeNavs[$nav['upid']]['subs'][$nav['nid']] = $nav; continue; } if ($this->_isInPos($postion, $nav['pos'])) { $currentPostionsKeeper[$nav['nid']] = $this->_compareIsCurrent($currentPostion, $nav['nkey']); $relativeNavs[$nav['nid']]['data'] = $nav; } else { $notValidParent[$nav['nid']] = $nav['nid']; } } $maxCurrentStatus = !empty($currentPostionsKeeper) ? max($currentPostionsKeeper) : 0; if ($maxCurrentStatus) { $relativeNavs[array_search($maxCurrentStatus, $currentPostionsKeeper)]['data']['iscurrent'] = true; } foreach ($notValidParent as $navId) { unset($relativeNavs[$navId]); } return $relativeNavs; }  function _compareIsCurrent($currentPostion, $navKey) { if (!is_array($currentPostion) || !count($currentPostion) || '' == $navKey) return 0; if ($currentPostion['mode'] == $navKey) return 1; if (implode("_", $currentPostion) == $navKey) return 2; return 0; }  function _getNavConfigDB() { return L::loadDB('navconfig', 'site'); } function _checkNavType($navType) { return in_array($navType, array(PW_NAV_TYPE_MAIN, PW_NAV_TYPE_HEAD_LEFT, PW_NAV_TYPE_HEAD_RIGHT, PW_NAV_TYPE_FOOT)); } function _encodePosField($posValue) { if ('-1' == $posValue) return $posValue; if (is_array($posValue)) return implode(',', $posValue); return ''; } function _decodePosField($posField) { if ('-1' == $posField) return $posField; if ($posField) return explode(',', $posField); return array(); } function _isInPos($postion, $posValue) { if ('-1' == $posValue) return true; if (is_array($posValue)) return in_array($postion, $posValue); return false; } function _encodeStyleField($styleData) { return implode("|", array($styleData['color'], $styleData['b'], $styleData['i'], $styleData['u'])); } function _decodeStyleField($styleField) { $styleField = explode('|', $styleField); return array('color'=>$styleField[0], 'b'=>$styleField[1], 'i'=>$styleField[2], 'u'=>$styleField[3]); }  function userHomeNavigation($type,$model) { if (!$type || !$model) return array(); $homenavigations = $this->findValidNavListByTypeAndPostion($type, $model); if (!S::isArray($homenavigations)) return array(); $homenavigation = array(); $homenavigation['linkup'][] = array_shift($homenavigations); $homenavigation['linkup'][] = array_shift($homenavigations); $homenavigation['linkup'][] = array_shift($homenavigations); foreach ($homenavigations as $value) { $homenavigation['linkdown'][] = $value; } return $homenavigation; } } !function_exists('readover') && exit('Forbidden');  class PW_BbsInfoService { function getBbsInfoById($id){ $id = S::int ( $id ); if ($id < 1) return false; if (perf::checkMemcache()) { $_cacheService = Perf::gatherCache('pw_bbsinfo'); return $_cacheService->getBbsInfoById($id); } $bbsInfoDb = $this->_getBbsInfoDB(); return $bbsInfoDb->get($id); }  function _getBbsInfoDB() { return L::loadDB('bbsinfo', 'forum'); } }!defined('P_W') && exit('Forbidden'); class PW_BbsinfoDB extends BaseDB { var $_tableName = 'pw_bbsinfo'; var $_primaryKey = 'id'; function get($id){ return $this->_get($id); } }! function_exists ( 'readover' ) && exit ( 'Forbidden' );  class PW_AutoJob { var $_db = null; var $_hour = 3600; var $_timestamp = null; var $_cache = true; function PW_AutoJob() { global $db, $timestamp; $this->_db = & $db; $this->_timestamp = $timestamp; } function run($userid, $groupid) { return $this->jobAutoController ( $userid, $groupid ); } function jobAutoController($userid, $groupid) { $userid = intval ( $userid ); $groupid = intval ( $groupid ); if ($groupid < 1 || $userid < 1) { return; } if (! $jobLists = $this->_jobAutoFilterHandler ( $userid, $groupid )) { return; } $current = $this->_timestamp; foreach ( $jobLists as $job ) { $this->_jobAutoCreateHandler ( $userid, $job, $current ); } } function _jobAutoFilterHandler($userid, $groupid) { $jobs = $this->getJobsAuto (); if (! $jobs) { return false; } $current = $this->_timestamp; $jobLists = $jobIds = $periods = $preposes = array (); foreach ( $jobs as $job ) { if ($job ['isopen'] == 0) { continue; } if ((isset ( $job ['endtime'] ) && $job ['endtime'] != 0 && $job ['endtime'] < $current)) { continue; } if ((isset ( $job ['starttime'] ) && $job ['starttime'] != 0 && $job ['starttime'] > $current)) { continue; } if (isset ( $job ['usergroup'] ) && $job ['usergroup'] != '') { $usergroups = explode ( ",", $job ['usergroup'] ); if (! in_array ( $groupid, $usergroups )) { continue; } } if (isset ( $job ['period'] ) && $job ['period'] > 0) { $periods [] = $job ['id']; } if (isset ( $job ['prepose'] ) && $job ['prepose'] > 0) { $preposes [$job ['prepose']] = $job ['id']; } if (isset ( $job ['number'] ) && $job ['number'] != 0) { $number = $this->countJoberByJobId ( $job ['id'] ); if ($number >= $job ['number']) { continue; } }  if (S::inArray($job['job'],array('doAuthAlipay','doAuthMobile'))) { if (!$GLOBALS['db_authstate']) return false; $userService = L::loadClass('UserService','user'); if ($job['job'] == 'doAuthAlipay' && $userService->getUserStatus($userid, PW_USERSTATUS_AUTHALIPAY)){ return false; } if ($job['job'] == 'doAuthMobile' && $userService->getUserStatus($userid, PW_USERSTATUS_AUTHMOBILE)){ return false; } } $jobLists [$job ['id']] = $job; $jobIds [] = $job ['id']; } if (! $jobLists) { return false; } $joins = $this->getJobersByJobIds ( $userid, $jobIds ); if ($joins) { foreach ( $joins as $join ) { $t_job = array (); $t_job = $jobLists [$join ['jobid']]; if (in_array ( $join ['jobid'], $periods )) { if ($join ['status'] >= 3 && $join ['total'] > 0) { if ($join ['next'] < $current) { $this->_jobAutoAgainHandler ( $userid, $t_job, $current ); } } } unset ( $t_job ); unset ( $jobLists [$join ['jobid']] ); } } if (! $jobLists) { return false; } if ($preposes) { $joins = $this->getJobersByJobIds ( $userid, array_keys ( $preposes ) ); if ($joins) { foreach ( $joins as $join ) { if ($join ['total'] > 0) { unset ( $preposes [$join ['jobid']] ); } } } if ($preposes) { foreach ( $preposes as $jobid ) { unset ( $jobLists [$jobid] ); } } } return $jobLists; } function _jobAutoAgainHandler($userid, $job, $current) { $next = $current; if (isset ( $job ['period'] ) && $job ['period'] != 0) { $next = $current + $job ['period'] * $this->_hour; } $job ['next'] = $next ? $next : $current; $this->_againJober ( $userid, $job ['id'], $job ['next'], $current ); } function _againJober($userId, $jobId, $next, $current, $jober = array()) { $jober = $jober ? $jober : $this->getJoberByJobId ( $userId, $jobId ); if (! $jober) { return array (); } $data = array (); $data ['current'] = 1; $data ['step'] = 0; $data ['last'] = $current; $data ['next'] = $next; $data ['status'] = 0; $result = $this->updateJober ( $data, $jober ['id'] ); if ($result) { $this->increaseJobNum ( $userId ); } return $result; } function updateJober($fields, $id) { $joberDao = $this->_getJoberDao (); return $joberDao->update ( $fields, $id ); } function getJobsAuto() { if ($this->_cache) { $jobs = $this->getFileCache (); if ($jobs) { $autos = array (); foreach ( $jobs as $job ) { if ($job ['auto'] == 1) { $autos [] = $job; } } return $autos; } } $jobDao = $this->_getJobDao (); return $jobDao->getByAuto (); } function getFileCache() { if (! $this->_cache) { return array (); }  extract(pwCache::getData(S::escapePath ( $this->getCacheFileName ()), false)); $jobLists = ($jobLists) ? $jobLists : $GLOBALS ['jobLists']; if ($jobLists) { return $jobLists; } return $this->setFileCache (); } function setFileCache() { $jobDao = $this->_getJobDao (); $jobs = $jobDao->getAll (); $jobLists = "\$jobLists=" . pw_var_export ( $jobs ) . ";"; pwCache::setData ( $this->getCacheFileName (), "<?php\r\n" . $jobLists . "\r\n?>" ); return $jobs; } function _jobAutoCreateHandler($userid, $job, $current) { if (isset ( $job ['period'] ) && $job ['period'] != 0) { $next = $current + $job ['period'] * $this->_hour; $job ['next'] = $next ? $next : $current; } $this->_createJober ( $userid, $job ['id'], $job ['next'], $current ); } function _createJober($userId, $jobId, $next, $current, $jober = array()) { $jober = $jober ? $jober : $this->getJoberByJobId ( $userId, $jobId ); if ($jober) { return array (); } $data = array (); $data ['jobid'] = $jobId; $data ['userid'] = $userId; $data ['current'] = 1; $data ['step'] = 0; $data ['last'] = $current; $data ['next'] = $next; $data ['status'] = 0; $data ['creattime'] = $current; return $this->addJober ( $data ); } function getCacheFileName() { return R_P . "data/bbscache/jobs.php"; } function getJobersByJobIds($userid, $ids) { $joberDao = $this->_getJoberDao (); return $joberDao->getJobersByJobIds ( $userid, $ids ); } function addJober($fields) { $fields ['userid'] = intval ( $fields ['userid'] ); $fields ['jobid'] = intval ( $fields ['jobid'] ); if ($fields ['userid'] < 1 || $fields ['jobid'] < 1) { return null; } $joberDao = $this->_getJoberDao (); $result = $joberDao->add ( $fields ); if ($result) { $this->increaseJobNum ( $fields ['userid'] ); } return $result; } function increaseJobNum($userid) { $this->updateJobNum ( $userid ); } function updateJobNum($userid) { $jobnum = $this->countJobnum ( $userid ); ($jobnum > 0) ? $jobnum : 0; $userService = L::loadClass ( 'UserService', 'user' ); return $userService->update ( $userid, array (), array ('jobnum' => $jobnum ) ); } function countJobNum($userId) { if (! $userId) return false; $joblists = $this->getAppliedJobs ( $userId ); $joblists = $joblists ? $joblists : array (); $num = 0; foreach ( $joblists as $job ) { if ($job ['isopen'] == 0 || $job['isuserguide']) continue; $num ++; } return $num; } function getAppliedJobs($userid) { $joberDao = $this->_getJoberDao (); $jobers = $joberDao->getAppliedJobs ( $userid ); if (! $jobers) { return array (); } return $this->buildJobListByIds ( $jobers ); } function buildJobListByIds($jobers) { if (! $jobers) { return array (); } $jobIds = $tmp = array (); foreach ( $jobers as $job ) { $jobIds [] = $job ['jobid']; $tmp [$job ['jobid']] = $job; } $jobs = $this->getJobsByIds ( $jobIds ); if (! $jobs) { return array (); } $result = array (); foreach ( $jobs as $job ) { $result [] = array_merge ( $tmp [$job ['id']], $job ); } return $result; } function getJobsByIds($jobIds) { if ($this->_cache) { $jobs = $this->getFileCache (); if ($jobs) { $result = array (); foreach ( $jobs as $job ) { if (in_array ( $job ['id'], $jobIds )) { $result [] = $job; } } return $result; } } $jobDao = $this->_getJobDao (); return $jobDao->getByIds ( $jobIds ); } function getJoberByJobId($userId, $jobId) { $joberDao = $this->_getJoberDao (); return $joberDao->getByJobId ( $userId, $jobId ); } function countJoberByJobId($jobid) { $joberDao = $this->_getJoberDao (); return $joberDao->countByJobId ( $jobid ); } function _getJobDao() { $job = L::loadDB ( 'job', 'job' ); return $job; } function _getJoberDao() { $job = L::loadDB ( 'jober', 'job' ); return $job; } function _getJobDoerDao() { $job = L::loadDB ( 'jobdoer', 'job' ); return $job; } }! defined ( 'P_W' ) && exit ( 'Forbidden' ); class PW_JoberDB extends BaseDB { var $_tableName = "pw_jober"; function add($fieldData) { $this->_db->update ( "INSERT INTO " . $this->_tableName . " SET " . $this->_getUpdateSqlString ( $fieldData ) ); return $this->_db->insert_id (); } function update($fieldData, $id) { $this->_db->update ( "UPDATE " . $this->_tableName . " SET " . $this->_getUpdateSqlString ( $fieldData ) . " WHERE id=" . $this->_addSlashes ( $id ) . " LIMIT 1" ); return $this->_db->affected_rows (); } function delete($id) { $this->_db->update ( "DELETE FROM " . $this->_tableName . " WHERE id=" . $this->_addSlashes ( $id ) . " LIMIT 1" ); return $this->_db->affected_rows (); } function get($id) { $id = intval($id); if($id<1){ return null; } return $this->_db->get_one ( "SELECT * FROM " . $this->_tableName . " WHERE id=" . $this->_addSlashes ( $id ) . " LIMIT 1" ); } function getByJobId($userId,$jobId) { $userId = intval($userId); $jobId = intval($jobId); if($userId<1 || $jobId<1){ return null; } return $this->_db->get_one ( "SELECT * FROM " . $this->_tableName . " WHERE jobid=" . $this->_addSlashes ( $jobId ) . " AND userid =" . $this->_addSlashes ( $userId ) . " ORDER BY last DESC LIMIT 1" ); } function getAll() { $query = $this->_db->query ( "SELECT * FROM " . $this->_tableName ); return $this->_getAllResultFromQuery ( $query ); } function gets($offset,$limit) { $query = $this->_db->query ( "SELECT * FROM " . $this->_tableName. "  LIMIT " . $offset . "," . $limit ); return $this->_getAllResultFromQuery ( $query ); } function countByJobId($jobId){ $result = $this->_db->get_one ( "SELECT COUNT(*) AS total FROM " . $this->_tableName . " WHERE jobid=".$this->_addSlashes ( $jobId )."  LIMIT 1" ); return $result ['total']; } function getAppliedJobs($userid){ $userid = intval($userid); if($userid<1){ return null; } $query = $this->_db->query ( "SELECT * FROM " . $this->_tableName. " WHERE userid=".$this->_addSlashes ( $userid )." AND status<=2" ); return $this->_getAllResultFromQuery ( $query ); } function countAppliedJobs($userid){ $userid = intval($userid); if($userid<1){ return null; } return $this->_db->get_value ( "SELECT COUNT(*) as total FROM " . $this->_tableName. " WHERE userid=".$this->_addSlashes ( $userid )." AND status<2 LIMIT 1" ); } function getFinishJobs($userid){ $userid = intval($userid); if($userid<1){ return null; } $query = $this->_db->query ( "SELECT * FROM " . $this->_tableName. " WHERE userid=".$this->_addSlashes ( $userid )." AND total>0" ); return $this->_getAllResultFromQuery ( $query ); } function getQuitJobs($userid){ $userid = intval($userid); if($userid<1){ return null; } $query = $this->_db->query ( "SELECT * FROM " . $this->_tableName. " WHERE userid=".$this->_addSlashes ( $userid )." AND status>=4" ); return $this->_getAllResultFromQuery ( $query ); } function updateByJobId($fieldData, $jobid,$userid) { $userid = intval($userid); $jobid = intval($jobid); if($userid<1 || $jobid<1 ){ return null; } $this->_db->update ( "UPDATE " . $this->_tableName . " SET " . $this->_getUpdateSqlString ( $fieldData ) . "  WHERE jobid=" . $this->_addSlashes ( $jobid ) . " AND userid=" . $this->_addSlashes ( $userid ) . " LIMIT 1" ); return $this->_db->affected_rows (); }  function getsByJobIds($userid,$ids) { if(!is_array($ids)){ return array(); } $ids = implode(",",$ids); return $this->_db->get_one ( "SELECT * FROM " . $this->_tableName. "  WHERE jobid in(" .$ids. ") AND status <= 1 AND userid=".$this->_addSlashes ( $userid )." ORDER BY last DESC LIMIT 1" ); }  function getInProcessJobersByUserIdAndJobIds($userid, $ids) { $userid = (int) $userid; if(!S::isArray($ids) || $userid < 1) return array(); $query = $this->_db->query('SELECT * FROM ' . $this->_tableName . ' WHERE jobid IN(' . S::sqlImplode($ids) . ') AND status = 1 AND userid = ' . S::sqlEscape($userid) . ' ORDER BY last DESC'); return $this->_getAllResultFromQuery($query); } function getJobersByJobIds($userid,$ids) { $userid = intval($userid); if(!is_array($ids) || $userid<1 ){ return array(); } $ids = implode(",",$ids); $query = $this->_db->query ( "SELECT * FROM " . $this->_tableName. "  WHERE jobid in(" .$ids. ") AND userid=".$this->_addSlashes ( $userid )); return $this->_getAllResultFromQuery ( $query ); } function getJobersByJobIdAndUserId($userid,$jobid) { $userid = intval($userid); $jobid = intval($jobid); if($userid<1 || $jobid<1 ){ return null; } $query = $this->_db->query ( "SELECT * FROM " . $this->_tableName. "  WHERE jobid=" .$this->_addSlashes($jobid)." AND userid != ".$this->_addSlashes($userid)." AND total>0 LIMIT 20"); return $this->_getAllResultFromQuery ( $query ); } function countJobersByJobIdAndUserId($userid,$jobid) { $userid = intval($userid); $jobid = intval($jobid); if($userid<1 || $jobid<1 ){ return null; } $result = $this->_db->get_one ( "SELECT COUNT(*) as total FROM " . $this->_tableName. "  WHERE jobid=" .$this->_addSlashes($jobid)." AND userid != ".$this->_addSlashes($userid)." AND total>0"); return $result['total']; } } !defined('P_W') && exit('Forbidden');  class PW_Errors { var $_errors = array();  var $_logs = array();   function addError($errorInfo) { $this->_errors[] = $errorInfo; }  function addLog($logInfo) { $this->_logs[] = $logInfo; }  function writeLog($method = 'rb+') { $logFile = D_P.'data/error.log'; if (!$this->_logs) return false; $temp = pw_var_export($this->_logs); pwCache::writeover($logFile,$temp, 'rb+'); }  function checkError($jumpurl = '') { foreach ($this->_errors as $error) { $this->showError($error,$jumpurl); } }  function showError($error, $jumpurl = '') { Showmsg($error, $jumpurl); } function __destruct() { if (!defined('SHOWLOG')) return false; $this->writeLog(); } }